        -:    0:Source:/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/locale
        -:    0:Graph:HealthMonitor_Alert_test.cpp.gcno
        -:    0:Data:HealthMonitor_Alert_test.cpp.gcda
        -:    0:Runs:2
        -:    0:Programs:1
        -:    1:// -*- C++ -*-
        -:    2://===----------------------------------------------------------------------===//
        -:    3://
        -:    4:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    5:// See https://llvm.org/LICENSE.txt for license information.
        -:    6:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    7://
        -:    8://===----------------------------------------------------------------------===//
        -:    9:
        -:   10:#ifndef _LIBCPP_LOCALE
        -:   11:#define _LIBCPP_LOCALE
        -:   12:
        -:   13:/*
        -:   14:    locale synopsis
        -:   15:
        -:   16:namespace std
        -:   17:{
        -:   18:
        -:   19:class locale
        -:   20:{
        -:   21:public:
        -:   22:    // types:
        -:   23:    class facet;
        -:   24:    class id;
        -:   25:
        -:   26:    typedef int category;
        -:   27:    static const category // values assigned here are for exposition only
        -:   28:        none     = 0x000,
        -:   29:        collate  = 0x010,
        -:   30:        ctype    = 0x020,
        -:   31:        monetary = 0x040,
        -:   32:        numeric  = 0x080,
        -:   33:        time     = 0x100,
        -:   34:        messages = 0x200,
        -:   35:        all = collate | ctype | monetary | numeric | time | messages;
        -:   36:
        -:   37:    // construct/copy/destroy:
        -:   38:    locale() noexcept;
        -:   39:    locale(const locale& other) noexcept;
        -:   40:    explicit locale(const char* std_name);
        -:   41:    explicit locale(const string& std_name);
        -:   42:    locale(const locale& other, const char* std_name, category);
        -:   43:    locale(const locale& other, const string& std_name, category);
        -:   44:    template <class Facet> locale(const locale& other, Facet* f);
        -:   45:    locale(const locale& other, const locale& one, category);
        -:   46:
        -:   47:    ~locale(); // not virtual
        -:   48:
        -:   49:    const locale& operator=(const locale& other) noexcept;
        -:   50:
        -:   51:    template <class Facet> locale combine(const locale& other) const;
        -:   52:
        -:   53:    // locale operations:
        -:   54:    basic_string<char> name() const;
        -:   55:    bool operator==(const locale& other) const;
        -:   56:    bool operator!=(const locale& other) const;                              // removed C++20
        -:   57:    template <class charT, class Traits, class Allocator>
        -:   58:      bool operator()(const basic_string<charT,Traits,Allocator>& s1,
        -:   59:                      const basic_string<charT,Traits,Allocator>& s2) const;
        -:   60:
        -:   61:    // global locale objects:
        -:   62:    static locale global(const locale&);
        -:   63:    static const locale& classic();
        -:   64:};
        -:   65:
        -:   66:template <class Facet> const Facet& use_facet(const locale&);
        -:   67:template <class Facet> bool has_facet(const locale&) noexcept;
        -:   68:
        -:   69:// 22.3.3, convenience interfaces:
        -:   70:template <class charT> bool isspace (charT c, const locale& loc);
        -:   71:template <class charT> bool isprint (charT c, const locale& loc);
        -:   72:template <class charT> bool iscntrl (charT c, const locale& loc);
        -:   73:template <class charT> bool isupper (charT c, const locale& loc);
        -:   74:template <class charT> bool islower (charT c, const locale& loc);
        -:   75:template <class charT> bool isalpha (charT c, const locale& loc);
        -:   76:template <class charT> bool isdigit (charT c, const locale& loc);
        -:   77:template <class charT> bool ispunct (charT c, const locale& loc);
        -:   78:template <class charT> bool isxdigit(charT c, const locale& loc);
        -:   79:template <class charT> bool isalnum (charT c, const locale& loc);
        -:   80:template <class charT> bool isgraph (charT c, const locale& loc);
        -:   81:template <class charT> charT toupper(charT c, const locale& loc);
        -:   82:template <class charT> charT tolower(charT c, const locale& loc);
        -:   83:
        -:   84:template<class Codecvt, class Elem = wchar_t,
        -:   85:         class Wide_alloc = allocator<Elem>,
        -:   86:         class Byte_alloc = allocator<char>>
        -:   87:class wstring_convert                                      // Removed in C++26
        -:   88:{
        -:   89:public:
        -:   90:    typedef basic_string<char, char_traits<char>, Byte_alloc> byte_string;
        -:   91:    typedef basic_string<Elem, char_traits<Elem>, Wide_alloc> wide_string;
        -:   92:    typedef typename Codecvt::state_type                      state_type;
        -:   93:    typedef typename wide_string::traits_type::int_type       int_type;
        -:   94:
        -:   95:    wstring_convert(Codecvt* pcvt = new Codecvt);          // before C++14
        -:   96:    explicit wstring_convert(Codecvt* pcvt = new Codecvt); // before C++20
        -:   97:    wstring_convert() : wstring_convert(new Codecvt) {}    // C++20
        -:   98:    explicit wstring_convert(Codecvt* pcvt);               // C++20
        -:   99:
        -:  100:    wstring_convert(Codecvt* pcvt, state_type state);
        -:  101:    explicit wstring_convert(const byte_string& byte_err,           // explicit in C++14
        -:  102:                    const wide_string& wide_err = wide_string());
        -:  103:    wstring_convert(const wstring_convert&) = delete;               // C++14
        -:  104:    wstring_convert & operator=(const wstring_convert &) = delete;  // C++14
        -:  105:    ~wstring_convert();
        -:  106:
        -:  107:    wide_string from_bytes(char byte);
        -:  108:    wide_string from_bytes(const char* ptr);
        -:  109:    wide_string from_bytes(const byte_string& str);
        -:  110:    wide_string from_bytes(const char* first, const char* last);
        -:  111:
        -:  112:    byte_string to_bytes(Elem wchar);
        -:  113:    byte_string to_bytes(const Elem* wptr);
        -:  114:    byte_string to_bytes(const wide_string& wstr);
        -:  115:    byte_string to_bytes(const Elem* first, const Elem* last);
        -:  116:
        -:  117:    size_t converted() const; // noexcept in C++14
        -:  118:    state_type state() const;
        -:  119:};
        -:  120:
        -:  121:template <class Codecvt, class Elem = wchar_t, class Tr = char_traits<Elem>>
        -:  122:class wbuffer_convert                                               // Removed in C++26
        -:  123:    : public basic_streambuf<Elem, Tr>
        -:  124:{
        -:  125:public:
        -:  126:    typedef typename Tr::state_type state_type;
        -:  127:
        -:  128:    wbuffer_convert(streambuf* bytebuf = 0, Codecvt* pcvt = new Codecvt,
        -:  129:                    state_type state = state_type());          // before C++14
        -:  130:    explicit wbuffer_convert(streambuf* bytebuf = nullptr, Codecvt* pcvt = new Codecvt,
        -:  131:                            state_type state = state_type()); // before C++20
        -:  132:    wbuffer_convert() : wbuffer_convert(nullptr) {} // C++20
        -:  133:    explicit wbuffer_convert(streambuf* bytebuf, Codecvt* pcvt = new Codecvt,
        -:  134:                            state_type state = state_type()); // C++20
        -:  135:
        -:  136:    wbuffer_convert(const wbuffer_convert&) = delete;               // C++14
        -:  137:    wbuffer_convert & operator=(const wbuffer_convert &) = delete;  // C++14
        -:  138:    ~wbuffer_convert();                                             // C++14
        -:  139:
        -:  140:    streambuf* rdbuf() const;
        -:  141:    streambuf* rdbuf(streambuf* bytebuf);
        -:  142:
        -:  143:    state_type state() const;
        -:  144:};
        -:  145:
        -:  146:// 22.4.1 and 22.4.1.3, ctype:
        -:  147:class ctype_base;
        -:  148:template <class charT> class ctype;
        -:  149:template <> class ctype<char>; // specialization
        -:  150:template <class charT> class ctype_byname;
        -:  151:template <> class ctype_byname<char>; // specialization
        -:  152:
        -:  153:class codecvt_base;
        -:  154:template <class internT, class externT, class stateT> class codecvt;
        -:  155:template <class internT, class externT, class stateT> class codecvt_byname;
        -:  156:
        -:  157:// 22.4.2 and 22.4.3, numeric:
        -:  158:template <class charT, class InputIterator> class num_get;
        -:  159:template <class charT, class OutputIterator> class num_put;
        -:  160:template <class charT> class numpunct;
        -:  161:template <class charT> class numpunct_byname;
        -:  162:
        -:  163:// 22.4.4, col lation:
        -:  164:template <class charT> class collate;
        -:  165:template <class charT> class collate_byname;
        -:  166:
        -:  167:// 22.4.5, date and time:
        -:  168:class time_base;
        -:  169:template <class charT, class InputIterator> class time_get;
        -:  170:template <class charT, class InputIterator> class time_get_byname;
        -:  171:template <class charT, class OutputIterator> class time_put;
        -:  172:template <class charT, class OutputIterator> class time_put_byname;
        -:  173:
        -:  174:// 22.4.6, money:
        -:  175:class money_base;
        -:  176:template <class charT, class InputIterator> class money_get;
        -:  177:template <class charT, class OutputIterator> class money_put;
        -:  178:template <class charT, bool Intl> class moneypunct;
        -:  179:template <class charT, bool Intl> class moneypunct_byname;
        -:  180:
        -:  181:// 22.4.7, message retrieval:
        -:  182:class messages_base;
        -:  183:template <class charT> class messages;
        -:  184:template <class charT> class messages_byname;
        -:  185:
        -:  186:}  // std
        -:  187:
        -:  188:*/
        -:  189:
        -:  190:#include <__config>
        -:  191:
        -:  192:#if !defined(_LIBCPP_HAS_NO_LOCALIZATION)
        -:  193:
        -:  194:#  include <__algorithm/copy.h>
        -:  195:#  include <__algorithm/equal.h>
        -:  196:#  include <__algorithm/find.h>
        -:  197:#  include <__algorithm/max.h>
        -:  198:#  include <__algorithm/reverse.h>
        -:  199:#  include <__algorithm/unwrap_iter.h>
        -:  200:#  include <__assert>
        -:  201:#  include <__iterator/access.h>
        -:  202:#  include <__iterator/back_insert_iterator.h>
        -:  203:#  include <__iterator/istreambuf_iterator.h>
        -:  204:#  include <__iterator/ostreambuf_iterator.h>
        -:  205:#  include <__locale>
        -:  206:#  include <__memory/unique_ptr.h>
        -:  207:#  include <__type_traits/make_unsigned.h>
        -:  208:#  include <cerrno>
        -:  209:#  include <cstdio>
        -:  210:#  include <cstdlib>
        -:  211:#  include <ctime>
        -:  212:#  include <ios>
        -:  213:#  include <limits>
        -:  214:#  include <new>
        -:  215:#  include <streambuf>
        -:  216:#  include <version>
        -:  217:
        -:  218:// TODO: Fix __bsd_locale_defaults.h
        -:  219:// NOLINTBEGIN(libcpp-robust-against-adl)
        -:  220:
        -:  221:#  if defined(__unix__) || (defined(__APPLE__) && defined(__MACH__) && !defined(_LIBCPP_ON_SEP))
        -:  222:// Most unix variants have catopen.  These are the specific ones that don't.
        -:  223:#    if !defined(__BIONIC__) && !defined(_NEWLIB_VERSION) && !defined(__EMSCRIPTEN__)
        -:  224:#      define _LIBCPP_HAS_CATOPEN 1
        -:  225:#      include <nl_types.h>
        -:  226:#    endif
        -:  227:#  endif
        -:  228:
        -:  229:#  ifdef _LIBCPP_LOCALE__L_EXTENSIONS
        -:  230:#    include <__locale_dir/locale_base_api/bsd_locale_defaults.h>
        -:  231:#  else
        -:  232:#    include <__locale_dir/locale_base_api/bsd_locale_fallbacks.h>
        -:  233:#  endif
        -:  234:
        -:  235:#  if defined(__APPLE__) || defined(__FreeBSD__)
        -:  236:#    include <xlocale.h>
        -:  237:#  endif
        -:  238:
        -:  239:#  if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
        -:  240:#    pragma GCC system_header
        -:  241:#  endif
        -:  242:
        -:  243:_LIBCPP_PUSH_MACROS
        -:  244:#  include <__undef_macros>
        -:  245:
        -:  246:_LIBCPP_BEGIN_NAMESPACE_STD
        -:  247:
        -:  248:#  if defined(__APPLE__) || defined(__FreeBSD__)
        -:  249:#    define _LIBCPP_GET_C_LOCALE 0
        -:  250:#  elif defined(__NetBSD__)
        -:  251:#    define _LIBCPP_GET_C_LOCALE LC_C_LOCALE
        -:  252:#  else
        -:  253:#    define _LIBCPP_GET_C_LOCALE __cloc()
        -:  254:// Get the C locale object
        -:  255:_LIBCPP_EXPORTED_FROM_ABI locale_t __cloc();
        -:  256:#    define __cloc_defined
        -:  257:#  endif
        -:  258:
        -:  259:// __scan_keyword
        -:  260:// Scans [__b, __e) until a match is found in the basic_strings range
        -:  261://  [__kb, __ke) or until it can be shown that there is no match in [__kb, __ke).
        -:  262://  __b will be incremented (visibly), consuming CharT until a match is found
        -:  263://  or proved to not exist.  A keyword may be "", in which will match anything.
        -:  264://  If one keyword is a prefix of another, and the next CharT in the input
        -:  265://  might match another keyword, the algorithm will attempt to find the longest
        -:  266://  matching keyword.  If the longer matching keyword ends up not matching, then
        -:  267://  no keyword match is found.  If no keyword match is found, __ke is returned
        -:  268://  and failbit is set in __err.
        -:  269://  Else an iterator pointing to the matching keyword is found.  If more than
        -:  270://  one keyword matches, an iterator to the first matching keyword is returned.
        -:  271://  If on exit __b == __e, eofbit is set in __err.  If __case_sensitive is false,
        -:  272://  __ct is used to force to lower case before comparing characters.
        -:  273://  Examples:
        -:  274://  Keywords:  "a", "abb"
        -:  275://  If the input is "a", the first keyword matches and eofbit is set.
        -:  276://  If the input is "abc", no match is found and "ab" are consumed.
        -:  277:template <class _InputIterator, class _ForwardIterator, class _Ctype>
        -:  278:_LIBCPP_HIDE_FROM_ABI _ForwardIterator __scan_keyword(
        -:  279:    _InputIterator& __b,
        -:  280:    _InputIterator __e,
        -:  281:    _ForwardIterator __kb,
        -:  282:    _ForwardIterator __ke,
        -:  283:    const _Ctype& __ct,
        -:  284:    ios_base::iostate& __err,
        -:  285:    bool __case_sensitive = true) {
        -:  286:  typedef typename iterator_traits<_InputIterator>::value_type _CharT;
        -:  287:  size_t __nkw                       = static_cast<size_t>(std::distance(__kb, __ke));
        -:  288:  const unsigned char __doesnt_match = '\0';
        -:  289:  const unsigned char __might_match  = '\1';
        -:  290:  const unsigned char __does_match   = '\2';
        -:  291:  unsigned char __statbuf[100];
        -:  292:  unsigned char* __status = __statbuf;
        -:  293:  unique_ptr<unsigned char, void (*)(void*)> __stat_hold(nullptr, free);
        -:  294:  if (__nkw > sizeof(__statbuf)) {
        -:  295:    __status = (unsigned char*)malloc(__nkw);
        -:  296:    if (__status == nullptr)
        -:  297:      __throw_bad_alloc();
        -:  298:    __stat_hold.reset(__status);
        -:  299:  }
        -:  300:  size_t __n_might_match = __nkw; // At this point, any keyword might match
        -:  301:  size_t __n_does_match  = 0;     // but none of them definitely do
        -:  302:  // Initialize all statuses to __might_match, except for "" keywords are __does_match
        -:  303:  unsigned char* __st = __status;
        -:  304:  for (_ForwardIterator __ky = __kb; __ky != __ke; ++__ky, (void)++__st) {
        -:  305:    if (!__ky->empty())
        -:  306:      *__st = __might_match;
        -:  307:    else {
        -:  308:      *__st = __does_match;
        -:  309:      --__n_might_match;
        -:  310:      ++__n_does_match;
        -:  311:    }
        -:  312:  }
        -:  313:  // While there might be a match, test keywords against the next CharT
        -:  314:  for (size_t __indx = 0; __b != __e && __n_might_match > 0; ++__indx) {
        -:  315:    // Peek at the next CharT but don't consume it
        -:  316:    _CharT __c = *__b;
        -:  317:    if (!__case_sensitive)
        -:  318:      __c = __ct.toupper(__c);
        -:  319:    bool __consume = false;
        -:  320:    // For each keyword which might match, see if the __indx character is __c
        -:  321:    // If a match if found, consume __c
        -:  322:    // If a match is found, and that is the last character in the keyword,
        -:  323:    //    then that keyword matches.
        -:  324:    // If the keyword doesn't match this character, then change the keyword
        -:  325:    //    to doesn't match
        -:  326:    __st = __status;
        -:  327:    for (_ForwardIterator __ky = __kb; __ky != __ke; ++__ky, (void)++__st) {
        -:  328:      if (*__st == __might_match) {
        -:  329:        _CharT __kc = (*__ky)[__indx];
        -:  330:        if (!__case_sensitive)
        -:  331:          __kc = __ct.toupper(__kc);
        -:  332:        if (__c == __kc) {
        -:  333:          __consume = true;
        -:  334:          if (__ky->size() == __indx + 1) {
        -:  335:            *__st = __does_match;
        -:  336:            --__n_might_match;
        -:  337:            ++__n_does_match;
        -:  338:          }
        -:  339:        } else {
        -:  340:          *__st = __doesnt_match;
        -:  341:          --__n_might_match;
        -:  342:        }
        -:  343:      }
        -:  344:    }
        -:  345:    // consume if we matched a character
        -:  346:    if (__consume) {
        -:  347:      ++__b;
        -:  348:      // If we consumed a character and there might be a matched keyword that
        -:  349:      //   was marked matched on a previous iteration, then such keywords
        -:  350:      //   which are now marked as not matching.
        -:  351:      if (__n_might_match + __n_does_match > 1) {
        -:  352:        __st = __status;
        -:  353:        for (_ForwardIterator __ky = __kb; __ky != __ke; ++__ky, (void)++__st) {
        -:  354:          if (*__st == __does_match && __ky->size() != __indx + 1) {
        -:  355:            *__st = __doesnt_match;
        -:  356:            --__n_does_match;
        -:  357:          }
        -:  358:        }
        -:  359:      }
        -:  360:    }
        -:  361:  }
        -:  362:  // We've exited the loop because we hit eof and/or we have no more "might matches".
        -:  363:  if (__b == __e)
        -:  364:    __err |= ios_base::eofbit;
        -:  365:  // Return the first matching result
        -:  366:  for (__st = __status; __kb != __ke; ++__kb, (void)++__st)
        -:  367:    if (*__st == __does_match)
        -:  368:      break;
        -:  369:  if (__kb == __ke)
        -:  370:    __err |= ios_base::failbit;
        -:  371:  return __kb;
        -:  372:}
        -:  373:
        -:  374:struct _LIBCPP_EXPORTED_FROM_ABI __num_get_base {
        -:  375:  static const int __num_get_buf_sz = 40;
        -:  376:
        -:  377:  static int __get_base(ios_base&);
        -:  378:  static const char __src[33]; // "0123456789abcdefABCDEFxX+-pPiInN"
        -:  379:  // count of leading characters in __src used for parsing integers ("012..X+-")
        -:  380:  static const size_t __int_chr_cnt = 26;
        -:  381:  // count of leading characters in __src used for parsing floating-point values ("012..-pP")
        -:  382:  static const size_t __fp_chr_cnt = 28;
        -:  383:};
        -:  384:
        -:  385:_LIBCPP_EXPORTED_FROM_ABI void
        -:  386:__check_grouping(const string& __grouping, unsigned* __g, unsigned* __g_end, ios_base::iostate& __err);
        -:  387:
        -:  388:template <class _CharT>
        -:  389:struct __num_get : protected __num_get_base {
        -:  390:  static string __stage2_float_prep(ios_base& __iob, _CharT* __atoms, _CharT& __decimal_point, _CharT& __thousands_sep);
        -:  391:
        -:  392:  static int __stage2_float_loop(
        -:  393:      _CharT __ct,
        -:  394:      bool& __in_units,
        -:  395:      char& __exp,
        -:  396:      char* __a,
        -:  397:      char*& __a_end,
        -:  398:      _CharT __decimal_point,
        -:  399:      _CharT __thousands_sep,
        -:  400:      const string& __grouping,
        -:  401:      unsigned* __g,
        -:  402:      unsigned*& __g_end,
        -:  403:      unsigned& __dc,
        -:  404:      _CharT* __atoms);
        -:  405:#  ifndef _LIBCPP_ABI_OPTIMIZED_LOCALE_NUM_GET
        -:  406:  static string __stage2_int_prep(ios_base& __iob, _CharT* __atoms, _CharT& __thousands_sep);
        -:  407:  static int __stage2_int_loop(
        -:  408:      _CharT __ct,
        -:  409:      int __base,
        -:  410:      char* __a,
        -:  411:      char*& __a_end,
        -:  412:      unsigned& __dc,
        -:  413:      _CharT __thousands_sep,
        -:  414:      const string& __grouping,
        -:  415:      unsigned* __g,
        -:  416:      unsigned*& __g_end,
        -:  417:      _CharT* __atoms);
        -:  418:
        -:  419:#  else
        -:  420:  static string __stage2_int_prep(ios_base& __iob, _CharT& __thousands_sep) {
        -:  421:    locale __loc                 = __iob.getloc();
        -:  422:    const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__loc);
        -:  423:    __thousands_sep              = __np.thousands_sep();
        -:  424:    return __np.grouping();
        -:  425:  }
        -:  426:
        -:  427:  const _CharT* __do_widen(ios_base& __iob, _CharT* __atoms) const { return __do_widen_p(__iob, __atoms); }
        -:  428:
        -:  429:  static int __stage2_int_loop(
        -:  430:      _CharT __ct,
        -:  431:      int __base,
        -:  432:      char* __a,
        -:  433:      char*& __a_end,
        -:  434:      unsigned& __dc,
        -:  435:      _CharT __thousands_sep,
        -:  436:      const string& __grouping,
        -:  437:      unsigned* __g,
        -:  438:      unsigned*& __g_end,
        -:  439:      const _CharT* __atoms);
        -:  440:
        -:  441:private:
        -:  442:  template <typename _Tp>
        -:  443:  const _Tp* __do_widen_p(ios_base& __iob, _Tp* __atoms) const {
        -:  444:    locale __loc = __iob.getloc();
        -:  445:    use_facet<ctype<_Tp> >(__loc).widen(__src, __src + __int_chr_cnt, __atoms);
        -:  446:    return __atoms;
        -:  447:  }
        -:  448:
        -:  449:  const char* __do_widen_p(ios_base& __iob, char* __atoms) const {
        -:  450:    (void)__iob;
        -:  451:    (void)__atoms;
        -:  452:    return __src;
        -:  453:  }
        -:  454:#  endif
        -:  455:};
        -:  456:
        -:  457:#  ifndef _LIBCPP_ABI_OPTIMIZED_LOCALE_NUM_GET
        -:  458:template <class _CharT>
        -:  459:string __num_get<_CharT>::__stage2_int_prep(ios_base& __iob, _CharT* __atoms, _CharT& __thousands_sep) {
        -:  460:  locale __loc = __iob.getloc();
        -:  461:  std::use_facet<ctype<_CharT> >(__loc).widen(__src, __src + __int_chr_cnt, __atoms);
        -:  462:  const numpunct<_CharT>& __np = std::use_facet<numpunct<_CharT> >(__loc);
        -:  463:  __thousands_sep              = __np.thousands_sep();
        -:  464:  return __np.grouping();
        -:  465:}
        -:  466:#  endif
        -:  467:
        -:  468:template <class _CharT>
        -:  469:string __num_get<_CharT>::__stage2_float_prep(
        -:  470:    ios_base& __iob, _CharT* __atoms, _CharT& __decimal_point, _CharT& __thousands_sep) {
        -:  471:  locale __loc = __iob.getloc();
        -:  472:  std::use_facet<ctype<_CharT> >(__loc).widen(__src, __src + __fp_chr_cnt, __atoms);
        -:  473:  const numpunct<_CharT>& __np = std::use_facet<numpunct<_CharT> >(__loc);
        -:  474:  __decimal_point              = __np.decimal_point();
        -:  475:  __thousands_sep              = __np.thousands_sep();
        -:  476:  return __np.grouping();
        -:  477:}
        -:  478:
        -:  479:template <class _CharT>
        -:  480:int
        -:  481:#  ifndef _LIBCPP_ABI_OPTIMIZED_LOCALE_NUM_GET
        -:  482:__num_get<_CharT>::__stage2_int_loop(_CharT __ct, int __base, char* __a, char*& __a_end,
        -:  483:                  unsigned& __dc, _CharT __thousands_sep, const string& __grouping,
        -:  484:                  unsigned* __g, unsigned*& __g_end, _CharT* __atoms)
        -:  485:#  else
        -:  486:__num_get<_CharT>::__stage2_int_loop(_CharT __ct, int __base, char* __a, char*& __a_end,
        -:  487:                  unsigned& __dc, _CharT __thousands_sep, const string& __grouping,
        -:  488:                  unsigned* __g, unsigned*& __g_end, const _CharT* __atoms)
        -:  489:
        -:  490:#  endif
        -:  491:{
        -:  492:  if (__a_end == __a && (__ct == __atoms[24] || __ct == __atoms[25])) {
        -:  493:    *__a_end++ = __ct == __atoms[24] ? '+' : '-';
        -:  494:    __dc       = 0;
        -:  495:    return 0;
        -:  496:  }
        -:  497:  if (__grouping.size() != 0 && __ct == __thousands_sep) {
        -:  498:    if (__g_end - __g < __num_get_buf_sz) {
        -:  499:      *__g_end++ = __dc;
        -:  500:      __dc       = 0;
        -:  501:    }
        -:  502:    return 0;
        -:  503:  }
        -:  504:  ptrdiff_t __f = std::find(__atoms, __atoms + __int_chr_cnt, __ct) - __atoms;
        -:  505:  if (__f >= 24)
        -:  506:    return -1;
        -:  507:  switch (__base) {
        -:  508:  case 8:
        -:  509:  case 10:
        -:  510:    if (__f >= __base)
        -:  511:      return -1;
        -:  512:    break;
        -:  513:  case 16:
        -:  514:    if (__f < 22)
        -:  515:      break;
        -:  516:    if (__a_end != __a && __a_end - __a <= 2 && __a_end[-1] == '0') {
        -:  517:      __dc       = 0;
        -:  518:      *__a_end++ = __src[__f];
        -:  519:      return 0;
        -:  520:    }
        -:  521:    return -1;
        -:  522:  }
        -:  523:  *__a_end++ = __src[__f];
        -:  524:  ++__dc;
        -:  525:  return 0;
        -:  526:}
        -:  527:
        -:  528:template <class _CharT>
        -:  529:int __num_get<_CharT>::__stage2_float_loop(
        -:  530:    _CharT __ct,
        -:  531:    bool& __in_units,
        -:  532:    char& __exp,
        -:  533:    char* __a,
        -:  534:    char*& __a_end,
        -:  535:    _CharT __decimal_point,
        -:  536:    _CharT __thousands_sep,
        -:  537:    const string& __grouping,
        -:  538:    unsigned* __g,
        -:  539:    unsigned*& __g_end,
        -:  540:    unsigned& __dc,
        -:  541:    _CharT* __atoms) {
        -:  542:  if (__ct == __decimal_point) {
        -:  543:    if (!__in_units)
        -:  544:      return -1;
        -:  545:    __in_units = false;
        -:  546:    *__a_end++ = '.';
        -:  547:    if (__grouping.size() != 0 && __g_end - __g < __num_get_buf_sz)
        -:  548:      *__g_end++ = __dc;
        -:  549:    return 0;
        -:  550:  }
        -:  551:  if (__ct == __thousands_sep && __grouping.size() != 0) {
        -:  552:    if (!__in_units)
        -:  553:      return -1;
        -:  554:    if (__g_end - __g < __num_get_buf_sz) {
        -:  555:      *__g_end++ = __dc;
        -:  556:      __dc       = 0;
        -:  557:    }
        -:  558:    return 0;
        -:  559:  }
        -:  560:  ptrdiff_t __f = std::find(__atoms, __atoms + __num_get_base::__fp_chr_cnt, __ct) - __atoms;
        -:  561:  if (__f >= static_cast<ptrdiff_t>(__num_get_base::__fp_chr_cnt))
        -:  562:    return -1;
        -:  563:  char __x = __src[__f];
        -:  564:  if (__x == '-' || __x == '+') {
        -:  565:    if (__a_end == __a || (std::toupper(__a_end[-1]) == std::toupper(__exp))) {
        -:  566:      *__a_end++ = __x;
        -:  567:      return 0;
        -:  568:    }
        -:  569:    return -1;
        -:  570:  }
        -:  571:  if (__x == 'x' || __x == 'X')
        -:  572:    __exp = 'P';
        -:  573:  else if (std::toupper(__x) == __exp) {
        -:  574:    __exp = std::tolower(__exp);
        -:  575:    if (__in_units) {
        -:  576:      __in_units = false;
        -:  577:      if (__grouping.size() != 0 && __g_end - __g < __num_get_buf_sz)
        -:  578:        *__g_end++ = __dc;
        -:  579:    }
        -:  580:  }
        -:  581:  *__a_end++ = __x;
        -:  582:  if (__f >= 22)
        -:  583:    return 0;
        -:  584:  ++__dc;
        -:  585:  return 0;
        -:  586:}
        -:  587:
        -:  588:extern template struct _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS __num_get<char>;
        -:  589:#  ifndef _LIBCPP_HAS_NO_WIDE_CHARACTERS
        -:  590:extern template struct _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS __num_get<wchar_t>;
        -:  591:#  endif
        -:  592:
        -:  593:template <class _CharT, class _InputIterator = istreambuf_iterator<_CharT> >
        -:  594:class _LIBCPP_TEMPLATE_VIS num_get : public locale::facet, private __num_get<_CharT> {
        -:  595:public:
        -:  596:  typedef _CharT char_type;
        -:  597:  typedef _InputIterator iter_type;
        -:  598:
        -:  599:  _LIBCPP_HIDE_FROM_ABI explicit num_get(size_t __refs = 0) : locale::facet(__refs) {}
        -:  600:
        -:  601:  _LIBCPP_HIDE_FROM_ABI iter_type
        -:  602:  get(iter_type __b, iter_type __e, ios_base& __iob, ios_base::iostate& __err, bool& __v) const {
        -:  603:    return do_get(__b, __e, __iob, __err, __v);
        -:  604:  }
        -:  605:
        -:  606:  _LIBCPP_HIDE_FROM_ABI iter_type
        -:  607:  get(iter_type __b, iter_type __e, ios_base& __iob, ios_base::iostate& __err, long& __v) const {
        -:  608:    return do_get(__b, __e, __iob, __err, __v);
        -:  609:  }
        -:  610:
        -:  611:  _LIBCPP_HIDE_FROM_ABI iter_type
        -:  612:  get(iter_type __b, iter_type __e, ios_base& __iob, ios_base::iostate& __err, long long& __v) const {
        -:  613:    return do_get(__b, __e, __iob, __err, __v);
        -:  614:  }
        -:  615:
        -:  616:  _LIBCPP_HIDE_FROM_ABI iter_type
        -:  617:  get(iter_type __b, iter_type __e, ios_base& __iob, ios_base::iostate& __err, unsigned short& __v) const {
        -:  618:    return do_get(__b, __e, __iob, __err, __v);
        -:  619:  }
        -:  620:
        -:  621:  _LIBCPP_HIDE_FROM_ABI iter_type
        -:  622:  get(iter_type __b, iter_type __e, ios_base& __iob, ios_base::iostate& __err, unsigned int& __v) const {
        -:  623:    return do_get(__b, __e, __iob, __err, __v);
        -:  624:  }
        -:  625:
        -:  626:  _LIBCPP_HIDE_FROM_ABI iter_type
        -:  627:  get(iter_type __b, iter_type __e, ios_base& __iob, ios_base::iostate& __err, unsigned long& __v) const {
        -:  628:    return do_get(__b, __e, __iob, __err, __v);
        -:  629:  }
        -:  630:
        -:  631:  _LIBCPP_HIDE_FROM_ABI iter_type
        -:  632:  get(iter_type __b, iter_type __e, ios_base& __iob, ios_base::iostate& __err, unsigned long long& __v) const {
        -:  633:    return do_get(__b, __e, __iob, __err, __v);
        -:  634:  }
        -:  635:
        -:  636:  _LIBCPP_HIDE_FROM_ABI iter_type
        -:  637:  get(iter_type __b, iter_type __e, ios_base& __iob, ios_base::iostate& __err, float& __v) const {
        -:  638:    return do_get(__b, __e, __iob, __err, __v);
        -:  639:  }
        -:  640:
        -:  641:  _LIBCPP_HIDE_FROM_ABI iter_type
        -:  642:  get(iter_type __b, iter_type __e, ios_base& __iob, ios_base::iostate& __err, double& __v) const {
        -:  643:    return do_get(__b, __e, __iob, __err, __v);
        -:  644:  }
        -:  645:
        -:  646:  _LIBCPP_HIDE_FROM_ABI iter_type
        -:  647:  get(iter_type __b, iter_type __e, ios_base& __iob, ios_base::iostate& __err, long double& __v) const {
        -:  648:    return do_get(__b, __e, __iob, __err, __v);
        -:  649:  }
        -:  650:
        -:  651:  _LIBCPP_HIDE_FROM_ABI iter_type
        -:  652:  get(iter_type __b, iter_type __e, ios_base& __iob, ios_base::iostate& __err, void*& __v) const {
        -:  653:    return do_get(__b, __e, __iob, __err, __v);
        -:  654:  }
        -:  655:
        -:  656:  static locale::id id;
        -:  657:
        -:  658:protected:
        -:  659:  _LIBCPP_HIDE_FROM_ABI_VIRTUAL ~num_get() override {}
        -:  660:
        -:  661:  template <class _Fp>
        -:  662:  _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS iter_type
        -:  663:  __do_get_floating_point(iter_type __b, iter_type __e, ios_base& __iob, ios_base::iostate& __err, _Fp& __v) const;
        -:  664:
        -:  665:  template <class _Signed>
        -:  666:  _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS iter_type
        -:  667:  __do_get_signed(iter_type __b, iter_type __e, ios_base& __iob, ios_base::iostate& __err, _Signed& __v) const;
        -:  668:
        -:  669:  template <class _Unsigned>
        -:  670:  _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS iter_type
        -:  671:  __do_get_unsigned(iter_type __b, iter_type __e, ios_base& __iob, ios_base::iostate& __err, _Unsigned& __v) const;
        -:  672:
        -:  673:  virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob, ios_base::iostate& __err, bool& __v) const;
        -:  674:
        -:  675:  virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob, ios_base::iostate& __err, long& __v) const {
        -:  676:    return this->__do_get_signed(__b, __e, __iob, __err, __v);
        -:  677:  }
        -:  678:
        -:  679:  virtual iter_type
        -:  680:  do_get(iter_type __b, iter_type __e, ios_base& __iob, ios_base::iostate& __err, long long& __v) const {
        -:  681:    return this->__do_get_signed(__b, __e, __iob, __err, __v);
        -:  682:  }
        -:  683:
        -:  684:  virtual iter_type
        -:  685:  do_get(iter_type __b, iter_type __e, ios_base& __iob, ios_base::iostate& __err, unsigned short& __v) const {
        -:  686:    return this->__do_get_unsigned(__b, __e, __iob, __err, __v);
        -:  687:  }
        -:  688:
        -:  689:  virtual iter_type
        -:  690:  do_get(iter_type __b, iter_type __e, ios_base& __iob, ios_base::iostate& __err, unsigned int& __v) const {
        -:  691:    return this->__do_get_unsigned(__b, __e, __iob, __err, __v);
        -:  692:  }
        -:  693:
        -:  694:  virtual iter_type
        -:  695:  do_get(iter_type __b, iter_type __e, ios_base& __iob, ios_base::iostate& __err, unsigned long& __v) const {
        -:  696:    return this->__do_get_unsigned(__b, __e, __iob, __err, __v);
        -:  697:  }
        -:  698:
        -:  699:  virtual iter_type
        -:  700:  do_get(iter_type __b, iter_type __e, ios_base& __iob, ios_base::iostate& __err, unsigned long long& __v) const {
        -:  701:    return this->__do_get_unsigned(__b, __e, __iob, __err, __v);
        -:  702:  }
        -:  703:
        -:  704:  virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob, ios_base::iostate& __err, float& __v) const {
        -:  705:    return this->__do_get_floating_point(__b, __e, __iob, __err, __v);
        -:  706:  }
        -:  707:
        -:  708:  virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob, ios_base::iostate& __err, double& __v) const {
        -:  709:    return this->__do_get_floating_point(__b, __e, __iob, __err, __v);
        -:  710:  }
        -:  711:
        -:  712:  virtual iter_type
        -:  713:  do_get(iter_type __b, iter_type __e, ios_base& __iob, ios_base::iostate& __err, long double& __v) const {
        -:  714:    return this->__do_get_floating_point(__b, __e, __iob, __err, __v);
        -:  715:  }
        -:  716:
        -:  717:  virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob, ios_base::iostate& __err, void*& __v) const;
        -:  718:};
        -:  719:
        -:  720:template <class _CharT, class _InputIterator>
        -:  721:locale::id num_get<_CharT, _InputIterator>::id;
        -:  722:
        -:  723:template <class _Tp>
        -:  724:_LIBCPP_HIDE_FROM_ABI _Tp
        -:  725:__num_get_signed_integral(const char* __a, const char* __a_end, ios_base::iostate& __err, int __base) {
        -:  726:  if (__a != __a_end) {
        -:  727:    __libcpp_remove_reference_t<decltype(errno)> __save_errno = errno;
        -:  728:    errno                                                     = 0;
        -:  729:    char* __p2;
        -:  730:    long long __ll                                               = strtoll_l(__a, &__p2, __base, _LIBCPP_GET_C_LOCALE);
        -:  731:    __libcpp_remove_reference_t<decltype(errno)> __current_errno = errno;
        -:  732:    if (__current_errno == 0)
        -:  733:      errno = __save_errno;
        -:  734:    if (__p2 != __a_end) {
        -:  735:      __err = ios_base::failbit;
        -:  736:      return 0;
        -:  737:    } else if (__current_errno == ERANGE || __ll < numeric_limits<_Tp>::min() || numeric_limits<_Tp>::max() < __ll) {
        -:  738:      __err = ios_base::failbit;
        -:  739:      if (__ll > 0)
        -:  740:        return numeric_limits<_Tp>::max();
        -:  741:      else
        -:  742:        return numeric_limits<_Tp>::min();
        -:  743:    }
        -:  744:    return static_cast<_Tp>(__ll);
        -:  745:  }
        -:  746:  __err = ios_base::failbit;
        -:  747:  return 0;
        -:  748:}
        -:  749:
        -:  750:template <class _Tp>
        -:  751:_LIBCPP_HIDE_FROM_ABI _Tp
        -:  752:__num_get_unsigned_integral(const char* __a, const char* __a_end, ios_base::iostate& __err, int __base) {
        -:  753:  if (__a != __a_end) {
        -:  754:    const bool __negate = *__a == '-';
        -:  755:    if (__negate && ++__a == __a_end) {
        -:  756:      __err = ios_base::failbit;
        -:  757:      return 0;
        -:  758:    }
        -:  759:    __libcpp_remove_reference_t<decltype(errno)> __save_errno = errno;
        -:  760:    errno                                                     = 0;
        -:  761:    char* __p2;
        -:  762:    unsigned long long __ll                                      = strtoull_l(__a, &__p2, __base, _LIBCPP_GET_C_LOCALE);
        -:  763:    __libcpp_remove_reference_t<decltype(errno)> __current_errno = errno;
        -:  764:    if (__current_errno == 0)
        -:  765:      errno = __save_errno;
        -:  766:    if (__p2 != __a_end) {
        -:  767:      __err = ios_base::failbit;
        -:  768:      return 0;
        -:  769:    } else if (__current_errno == ERANGE || numeric_limits<_Tp>::max() < __ll) {
        -:  770:      __err = ios_base::failbit;
        -:  771:      return numeric_limits<_Tp>::max();
        -:  772:    }
        -:  773:    _Tp __res = static_cast<_Tp>(__ll);
        -:  774:    if (__negate)
        -:  775:      __res = -__res;
        -:  776:    return __res;
        -:  777:  }
        -:  778:  __err = ios_base::failbit;
        -:  779:  return 0;
        -:  780:}
        -:  781:
        -:  782:template <class _Tp>
        -:  783:_LIBCPP_HIDE_FROM_ABI _Tp __do_strtod(const char* __a, char** __p2);
        -:  784:
        -:  785:template <>
        -:  786:inline _LIBCPP_HIDE_FROM_ABI float __do_strtod<float>(const char* __a, char** __p2) {
        -:  787:  return strtof_l(__a, __p2, _LIBCPP_GET_C_LOCALE);
        -:  788:}
        -:  789:
        -:  790:template <>
        -:  791:inline _LIBCPP_HIDE_FROM_ABI double __do_strtod<double>(const char* __a, char** __p2) {
        -:  792:  return strtod_l(__a, __p2, _LIBCPP_GET_C_LOCALE);
        -:  793:}
        -:  794:
        -:  795:template <>
        -:  796:inline _LIBCPP_HIDE_FROM_ABI long double __do_strtod<long double>(const char* __a, char** __p2) {
        -:  797:  return strtold_l(__a, __p2, _LIBCPP_GET_C_LOCALE);
        -:  798:}
        -:  799:
        -:  800:template <class _Tp>
        -:  801:_LIBCPP_HIDE_FROM_ABI _Tp __num_get_float(const char* __a, const char* __a_end, ios_base::iostate& __err) {
        -:  802:  if (__a != __a_end) {
        -:  803:    __libcpp_remove_reference_t<decltype(errno)> __save_errno = errno;
        -:  804:    errno                                                     = 0;
        -:  805:    char* __p2;
        -:  806:    _Tp __ld                                                     = std::__do_strtod<_Tp>(__a, &__p2);
        -:  807:    __libcpp_remove_reference_t<decltype(errno)> __current_errno = errno;
        -:  808:    if (__current_errno == 0)
        -:  809:      errno = __save_errno;
        -:  810:    if (__p2 != __a_end) {
        -:  811:      __err = ios_base::failbit;
        -:  812:      return 0;
        -:  813:    } else if (__current_errno == ERANGE)
        -:  814:      __err = ios_base::failbit;
        -:  815:    return __ld;
        -:  816:  }
        -:  817:  __err = ios_base::failbit;
        -:  818:  return 0;
        -:  819:}
        -:  820:
        -:  821:template <class _CharT, class _InputIterator>
        -:  822:_InputIterator num_get<_CharT, _InputIterator>::do_get(
        -:  823:    iter_type __b, iter_type __e, ios_base& __iob, ios_base::iostate& __err, bool& __v) const {
        -:  824:  if ((__iob.flags() & ios_base::boolalpha) == 0) {
        -:  825:    long __lv = -1;
        -:  826:    __b       = do_get(__b, __e, __iob, __err, __lv);
        -:  827:    switch (__lv) {
        -:  828:    case 0:
        -:  829:      __v = false;
        -:  830:      break;
        -:  831:    case 1:
        -:  832:      __v = true;
        -:  833:      break;
        -:  834:    default:
        -:  835:      __v   = true;
        -:  836:      __err = ios_base::failbit;
        -:  837:      break;
        -:  838:    }
        -:  839:    return __b;
        -:  840:  }
        -:  841:  const ctype<_CharT>& __ct    = std::use_facet<ctype<_CharT> >(__iob.getloc());
        -:  842:  const numpunct<_CharT>& __np = std::use_facet<numpunct<_CharT> >(__iob.getloc());
        -:  843:  typedef typename numpunct<_CharT>::string_type string_type;
        -:  844:  const string_type __names[2] = {__np.truename(), __np.falsename()};
        -:  845:  const string_type* __i       = std::__scan_keyword(__b, __e, __names, __names + 2, __ct, __err);
        -:  846:  __v                          = __i == __names;
        -:  847:  return __b;
        -:  848:}
        -:  849:
        -:  850:// signed
        -:  851:
        -:  852:template <class _CharT, class _InputIterator>
        -:  853:template <class _Signed>
        -:  854:_InputIterator num_get<_CharT, _InputIterator>::__do_get_signed(
        -:  855:    iter_type __b, iter_type __e, ios_base& __iob, ios_base::iostate& __err, _Signed& __v) const {
        -:  856:  // Stage 1
        -:  857:  int __base = this->__get_base(__iob);
        -:  858:  // Stage 2
        -:  859:  char_type __thousands_sep;
        -:  860:  const int __atoms_size = __num_get_base::__int_chr_cnt;
        -:  861:#  ifdef _LIBCPP_ABI_OPTIMIZED_LOCALE_NUM_GET
        -:  862:  char_type __atoms1[__atoms_size];
        -:  863:  const char_type* __atoms = this->__do_widen(__iob, __atoms1);
        -:  864:  string __grouping        = this->__stage2_int_prep(__iob, __thousands_sep);
        -:  865:#  else
        -:  866:  char_type __atoms[__atoms_size];
        -:  867:  string __grouping = this->__stage2_int_prep(__iob, __atoms, __thousands_sep);
        -:  868:#  endif
        -:  869:  string __buf;
        -:  870:  __buf.resize(__buf.capacity());
        -:  871:  char* __a     = &__buf[0];
        -:  872:  char* __a_end = __a;
        -:  873:  unsigned __g[__num_get_base::__num_get_buf_sz];
        -:  874:  unsigned* __g_end = __g;
        -:  875:  unsigned __dc     = 0;
        -:  876:  for (; __b != __e; ++__b) {
        -:  877:    if (__a_end == __a + __buf.size()) {
        -:  878:      size_t __tmp = __buf.size();
        -:  879:      __buf.resize(2 * __buf.size());
        -:  880:      __buf.resize(__buf.capacity());
        -:  881:      __a     = &__buf[0];
        -:  882:      __a_end = __a + __tmp;
        -:  883:    }
        -:  884:    if (this->__stage2_int_loop(*__b, __base, __a, __a_end, __dc, __thousands_sep, __grouping, __g, __g_end, __atoms))
        -:  885:      break;
        -:  886:  }
        -:  887:  if (__grouping.size() != 0 && __g_end - __g < __num_get_base::__num_get_buf_sz)
        -:  888:    *__g_end++ = __dc;
        -:  889:  // Stage 3
        -:  890:  __v = std::__num_get_signed_integral<_Signed>(__a, __a_end, __err, __base);
        -:  891:  // Digit grouping checked
        -:  892:  __check_grouping(__grouping, __g, __g_end, __err);
        -:  893:  // EOF checked
        -:  894:  if (__b == __e)
        -:  895:    __err |= ios_base::eofbit;
        -:  896:  return __b;
        -:  897:}
        -:  898:
        -:  899:// unsigned
        -:  900:
        -:  901:template <class _CharT, class _InputIterator>
        -:  902:template <class _Unsigned>
        -:  903:_InputIterator num_get<_CharT, _InputIterator>::__do_get_unsigned(
        -:  904:    iter_type __b, iter_type __e, ios_base& __iob, ios_base::iostate& __err, _Unsigned& __v) const {
        -:  905:  // Stage 1
        -:  906:  int __base = this->__get_base(__iob);
        -:  907:  // Stage 2
        -:  908:  char_type __thousands_sep;
        -:  909:  const int __atoms_size = __num_get_base::__int_chr_cnt;
        -:  910:#  ifdef _LIBCPP_ABI_OPTIMIZED_LOCALE_NUM_GET
        -:  911:  char_type __atoms1[__atoms_size];
        -:  912:  const char_type* __atoms = this->__do_widen(__iob, __atoms1);
        -:  913:  string __grouping        = this->__stage2_int_prep(__iob, __thousands_sep);
        -:  914:#  else
        -:  915:  char_type __atoms[__atoms_size];
        -:  916:  string __grouping = this->__stage2_int_prep(__iob, __atoms, __thousands_sep);
        -:  917:#  endif
        -:  918:  string __buf;
        -:  919:  __buf.resize(__buf.capacity());
        -:  920:  char* __a     = &__buf[0];
        -:  921:  char* __a_end = __a;
        -:  922:  unsigned __g[__num_get_base::__num_get_buf_sz];
        -:  923:  unsigned* __g_end = __g;
        -:  924:  unsigned __dc     = 0;
        -:  925:  for (; __b != __e; ++__b) {
        -:  926:    if (__a_end == __a + __buf.size()) {
        -:  927:      size_t __tmp = __buf.size();
        -:  928:      __buf.resize(2 * __buf.size());
        -:  929:      __buf.resize(__buf.capacity());
        -:  930:      __a     = &__buf[0];
        -:  931:      __a_end = __a + __tmp;
        -:  932:    }
        -:  933:    if (this->__stage2_int_loop(*__b, __base, __a, __a_end, __dc, __thousands_sep, __grouping, __g, __g_end, __atoms))
        -:  934:      break;
        -:  935:  }
        -:  936:  if (__grouping.size() != 0 && __g_end - __g < __num_get_base::__num_get_buf_sz)
        -:  937:    *__g_end++ = __dc;
        -:  938:  // Stage 3
        -:  939:  __v = std::__num_get_unsigned_integral<_Unsigned>(__a, __a_end, __err, __base);
        -:  940:  // Digit grouping checked
        -:  941:  __check_grouping(__grouping, __g, __g_end, __err);
        -:  942:  // EOF checked
        -:  943:  if (__b == __e)
        -:  944:    __err |= ios_base::eofbit;
        -:  945:  return __b;
        -:  946:}
        -:  947:
        -:  948:// floating point
        -:  949:
        -:  950:template <class _CharT, class _InputIterator>
        -:  951:template <class _Fp>
        -:  952:_InputIterator num_get<_CharT, _InputIterator>::__do_get_floating_point(
        -:  953:    iter_type __b, iter_type __e, ios_base& __iob, ios_base::iostate& __err, _Fp& __v) const {
        -:  954:  // Stage 1, nothing to do
        -:  955:  // Stage 2
        -:  956:  char_type __atoms[__num_get_base::__fp_chr_cnt];
        -:  957:  char_type __decimal_point;
        -:  958:  char_type __thousands_sep;
        -:  959:  string __grouping = this->__stage2_float_prep(__iob, __atoms, __decimal_point, __thousands_sep);
        -:  960:  string __buf;
        -:  961:  __buf.resize(__buf.capacity());
        -:  962:  char* __a     = &__buf[0];
        -:  963:  char* __a_end = __a;
        -:  964:  unsigned __g[__num_get_base::__num_get_buf_sz];
        -:  965:  unsigned* __g_end        = __g;
        -:  966:  unsigned __dc            = 0;
        -:  967:  bool __in_units          = true;
        -:  968:  char __exp               = 'E';
        -:  969:  bool __is_leading_parsed = false;
        -:  970:  for (; __b != __e; ++__b) {
        -:  971:    if (__a_end == __a + __buf.size()) {
        -:  972:      size_t __tmp = __buf.size();
        -:  973:      __buf.resize(2 * __buf.size());
        -:  974:      __buf.resize(__buf.capacity());
        -:  975:      __a     = &__buf[0];
        -:  976:      __a_end = __a + __tmp;
        -:  977:    }
        -:  978:    if (this->__stage2_float_loop(
        -:  979:            *__b,
        -:  980:            __in_units,
        -:  981:            __exp,
        -:  982:            __a,
        -:  983:            __a_end,
        -:  984:            __decimal_point,
        -:  985:            __thousands_sep,
        -:  986:            __grouping,
        -:  987:            __g,
        -:  988:            __g_end,
        -:  989:            __dc,
        -:  990:            __atoms))
        -:  991:      break;
        -:  992:
        -:  993:    // the leading character excluding the sign must be a decimal digit
        -:  994:    if (!__is_leading_parsed) {
        -:  995:      if (__a_end - __a >= 1 && __a[0] != '-' && __a[0] != '+') {
        -:  996:        if (('0' <= __a[0] && __a[0] <= '9') || __a[0] == '.')
        -:  997:          __is_leading_parsed = true;
        -:  998:        else
        -:  999:          break;
        -: 1000:      } else if (__a_end - __a >= 2 && (__a[0] == '-' || __a[0] == '+')) {
        -: 1001:        if (('0' <= __a[1] && __a[1] <= '9') || __a[1] == '.')
        -: 1002:          __is_leading_parsed = true;
        -: 1003:        else
        -: 1004:          break;
        -: 1005:      }
        -: 1006:    }
        -: 1007:  }
        -: 1008:  if (__grouping.size() != 0 && __in_units && __g_end - __g < __num_get_base::__num_get_buf_sz)
        -: 1009:    *__g_end++ = __dc;
        -: 1010:  // Stage 3
        -: 1011:  __v = std::__num_get_float<_Fp>(__a, __a_end, __err);
        -: 1012:  // Digit grouping checked
        -: 1013:  __check_grouping(__grouping, __g, __g_end, __err);
        -: 1014:  // EOF checked
        -: 1015:  if (__b == __e)
        -: 1016:    __err |= ios_base::eofbit;
        -: 1017:  return __b;
        -: 1018:}
        -: 1019:
        -: 1020:template <class _CharT, class _InputIterator>
        -: 1021:_InputIterator num_get<_CharT, _InputIterator>::do_get(
        -: 1022:    iter_type __b, iter_type __e, ios_base& __iob, ios_base::iostate& __err, void*& __v) const {
        -: 1023:  // Stage 1
        -: 1024:  int __base = 16;
        -: 1025:  // Stage 2
        -: 1026:  char_type __atoms[__num_get_base::__int_chr_cnt];
        -: 1027:  char_type __thousands_sep = char_type();
        -: 1028:  string __grouping;
        -: 1029:  std::use_facet<ctype<_CharT> >(__iob.getloc())
        -: 1030:      .widen(__num_get_base::__src, __num_get_base::__src + __num_get_base::__int_chr_cnt, __atoms);
        -: 1031:  string __buf;
        -: 1032:  __buf.resize(__buf.capacity());
        -: 1033:  char* __a     = &__buf[0];
        -: 1034:  char* __a_end = __a;
        -: 1035:  unsigned __g[__num_get_base::__num_get_buf_sz];
        -: 1036:  unsigned* __g_end = __g;
        -: 1037:  unsigned __dc     = 0;
        -: 1038:  for (; __b != __e; ++__b) {
        -: 1039:    if (__a_end == __a + __buf.size()) {
        -: 1040:      size_t __tmp = __buf.size();
        -: 1041:      __buf.resize(2 * __buf.size());
        -: 1042:      __buf.resize(__buf.capacity());
        -: 1043:      __a     = &__buf[0];
        -: 1044:      __a_end = __a + __tmp;
        -: 1045:    }
        -: 1046:    if (this->__stage2_int_loop(*__b, __base, __a, __a_end, __dc, __thousands_sep, __grouping, __g, __g_end, __atoms))
        -: 1047:      break;
        -: 1048:  }
        -: 1049:  // Stage 3
        -: 1050:  __buf.resize(__a_end - __a);
        -: 1051:  if (__libcpp_sscanf_l(__buf.c_str(), _LIBCPP_GET_C_LOCALE, "%p", &__v) != 1)
        -: 1052:    __err = ios_base::failbit;
        -: 1053:  // EOF checked
        -: 1054:  if (__b == __e)
        -: 1055:    __err |= ios_base::eofbit;
        -: 1056:  return __b;
        -: 1057:}
        -: 1058:
        -: 1059:extern template class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS num_get<char>;
        -: 1060:#  ifndef _LIBCPP_HAS_NO_WIDE_CHARACTERS
        -: 1061:extern template class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS num_get<wchar_t>;
        -: 1062:#  endif
        -: 1063:
        -: 1064:struct _LIBCPP_EXPORTED_FROM_ABI __num_put_base {
        -: 1065:protected:
        -: 1066:  static void __format_int(char* __fmt, const char* __len, bool __signd, ios_base::fmtflags __flags);
        -: 1067:  static bool __format_float(char* __fmt, const char* __len, ios_base::fmtflags __flags);
        -: 1068:  static char* __identify_padding(char* __nb, char* __ne, const ios_base& __iob);
        -: 1069:};
        -: 1070:
        -: 1071:template <class _CharT>
        -: 1072:struct __num_put : protected __num_put_base {
        -: 1073:  static void __widen_and_group_int(
        -: 1074:      char* __nb, char* __np, char* __ne, _CharT* __ob, _CharT*& __op, _CharT*& __oe, const locale& __loc);
        -: 1075:  static void __widen_and_group_float(
        -: 1076:      char* __nb, char* __np, char* __ne, _CharT* __ob, _CharT*& __op, _CharT*& __oe, const locale& __loc);
        -: 1077:};
        -: 1078:
        -: 1079:template <class _CharT>
        -: 1080:void __num_put<_CharT>::__widen_and_group_int(
        -: 1081:    char* __nb, char* __np, char* __ne, _CharT* __ob, _CharT*& __op, _CharT*& __oe, const locale& __loc) {
        -: 1082:  const ctype<_CharT>& __ct     = std::use_facet<ctype<_CharT> >(__loc);
        -: 1083:  const numpunct<_CharT>& __npt = std::use_facet<numpunct<_CharT> >(__loc);
        -: 1084:  string __grouping             = __npt.grouping();
        -: 1085:  if (__grouping.empty()) {
        -: 1086:    __ct.widen(__nb, __ne, __ob);
        -: 1087:    __oe = __ob + (__ne - __nb);
        -: 1088:  } else {
        -: 1089:    __oe       = __ob;
        -: 1090:    char* __nf = __nb;
        -: 1091:    if (*__nf == '-' || *__nf == '+')
        -: 1092:      *__oe++ = __ct.widen(*__nf++);
        -: 1093:    if (__ne - __nf >= 2 && __nf[0] == '0' && (__nf[1] == 'x' || __nf[1] == 'X')) {
        -: 1094:      *__oe++ = __ct.widen(*__nf++);
        -: 1095:      *__oe++ = __ct.widen(*__nf++);
        -: 1096:    }
        -: 1097:    std::reverse(__nf, __ne);
        -: 1098:    _CharT __thousands_sep = __npt.thousands_sep();
        -: 1099:    unsigned __dc          = 0;
        -: 1100:    unsigned __dg          = 0;
        -: 1101:    for (char* __p = __nf; __p < __ne; ++__p) {
        -: 1102:      if (static_cast<unsigned>(__grouping[__dg]) > 0 && __dc == static_cast<unsigned>(__grouping[__dg])) {
        -: 1103:        *__oe++ = __thousands_sep;
        -: 1104:        __dc    = 0;
        -: 1105:        if (__dg < __grouping.size() - 1)
        -: 1106:          ++__dg;
        -: 1107:      }
        -: 1108:      *__oe++ = __ct.widen(*__p);
        -: 1109:      ++__dc;
        -: 1110:    }
        -: 1111:    std::reverse(__ob + (__nf - __nb), __oe);
        -: 1112:  }
        -: 1113:  if (__np == __ne)
        -: 1114:    __op = __oe;
        -: 1115:  else
        -: 1116:    __op = __ob + (__np - __nb);
        -: 1117:}
        -: 1118:
        -: 1119:template <class _CharT>
        -: 1120:void __num_put<_CharT>::__widen_and_group_float(
        -: 1121:    char* __nb, char* __np, char* __ne, _CharT* __ob, _CharT*& __op, _CharT*& __oe, const locale& __loc) {
        -: 1122:  const ctype<_CharT>& __ct     = std::use_facet<ctype<_CharT> >(__loc);
        -: 1123:  const numpunct<_CharT>& __npt = std::use_facet<numpunct<_CharT> >(__loc);
        -: 1124:  string __grouping             = __npt.grouping();
        -: 1125:  __oe                          = __ob;
        -: 1126:  char* __nf                    = __nb;
        -: 1127:  if (*__nf == '-' || *__nf == '+')
        -: 1128:    *__oe++ = __ct.widen(*__nf++);
        -: 1129:  char* __ns;
        -: 1130:  if (__ne - __nf >= 2 && __nf[0] == '0' && (__nf[1] == 'x' || __nf[1] == 'X')) {
        -: 1131:    *__oe++ = __ct.widen(*__nf++);
        -: 1132:    *__oe++ = __ct.widen(*__nf++);
        -: 1133:    for (__ns = __nf; __ns < __ne; ++__ns)
        -: 1134:      if (!isxdigit_l(*__ns, _LIBCPP_GET_C_LOCALE))
        -: 1135:        break;
        -: 1136:  } else {
        -: 1137:    for (__ns = __nf; __ns < __ne; ++__ns)
        -: 1138:      if (!isdigit_l(*__ns, _LIBCPP_GET_C_LOCALE))
        -: 1139:        break;
        -: 1140:  }
        -: 1141:  if (__grouping.empty()) {
        -: 1142:    __ct.widen(__nf, __ns, __oe);
        -: 1143:    __oe += __ns - __nf;
        -: 1144:  } else {
        -: 1145:    std::reverse(__nf, __ns);
        -: 1146:    _CharT __thousands_sep = __npt.thousands_sep();
        -: 1147:    unsigned __dc          = 0;
        -: 1148:    unsigned __dg          = 0;
        -: 1149:    for (char* __p = __nf; __p < __ns; ++__p) {
        -: 1150:      if (__grouping[__dg] > 0 && __dc == static_cast<unsigned>(__grouping[__dg])) {
        -: 1151:        *__oe++ = __thousands_sep;
        -: 1152:        __dc    = 0;
        -: 1153:        if (__dg < __grouping.size() - 1)
        -: 1154:          ++__dg;
        -: 1155:      }
        -: 1156:      *__oe++ = __ct.widen(*__p);
        -: 1157:      ++__dc;
        -: 1158:    }
        -: 1159:    std::reverse(__ob + (__nf - __nb), __oe);
        -: 1160:  }
        -: 1161:  for (__nf = __ns; __nf < __ne; ++__nf) {
        -: 1162:    if (*__nf == '.') {
        -: 1163:      *__oe++ = __npt.decimal_point();
        -: 1164:      ++__nf;
        -: 1165:      break;
        -: 1166:    } else
        -: 1167:      *__oe++ = __ct.widen(*__nf);
        -: 1168:  }
        -: 1169:  __ct.widen(__nf, __ne, __oe);
        -: 1170:  __oe += __ne - __nf;
        -: 1171:  if (__np == __ne)
        -: 1172:    __op = __oe;
        -: 1173:  else
        -: 1174:    __op = __ob + (__np - __nb);
        -: 1175:}
        -: 1176:
        -: 1177:extern template struct _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS __num_put<char>;
        -: 1178:#  ifndef _LIBCPP_HAS_NO_WIDE_CHARACTERS
        -: 1179:extern template struct _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS __num_put<wchar_t>;
        -: 1180:#  endif
        -: 1181:
        -: 1182:template <class _CharT, class _OutputIterator = ostreambuf_iterator<_CharT> >
        -: 1183:class _LIBCPP_TEMPLATE_VIS num_put : public locale::facet, private __num_put<_CharT> {
        -: 1184:public:
        -: 1185:  typedef _CharT char_type;
        -: 1186:  typedef _OutputIterator iter_type;
        -: 1187:
        -: 1188:  _LIBCPP_HIDE_FROM_ABI explicit num_put(size_t __refs = 0) : locale::facet(__refs) {}
        -: 1189:
        -: 1190:  _LIBCPP_HIDE_FROM_ABI iter_type put(iter_type __s, ios_base& __iob, char_type __fl, bool __v) const {
        -: 1191:    return do_put(__s, __iob, __fl, __v);
        -: 1192:  }
        -: 1193:
        -: 1194:  _LIBCPP_HIDE_FROM_ABI iter_type put(iter_type __s, ios_base& __iob, char_type __fl, long __v) const {
        -: 1195:    return do_put(__s, __iob, __fl, __v);
        -: 1196:  }
        -: 1197:
        -: 1198:  _LIBCPP_HIDE_FROM_ABI iter_type put(iter_type __s, ios_base& __iob, char_type __fl, long long __v) const {
        -: 1199:    return do_put(__s, __iob, __fl, __v);
        -: 1200:  }
        -: 1201:
        -: 1202:  _LIBCPP_HIDE_FROM_ABI iter_type put(iter_type __s, ios_base& __iob, char_type __fl, unsigned long __v) const {
        -: 1203:    return do_put(__s, __iob, __fl, __v);
        -: 1204:  }
        -: 1205:
        -: 1206:  _LIBCPP_HIDE_FROM_ABI iter_type put(iter_type __s, ios_base& __iob, char_type __fl, unsigned long long __v) const {
        -: 1207:    return do_put(__s, __iob, __fl, __v);
        -: 1208:  }
        -: 1209:
        -: 1210:  _LIBCPP_HIDE_FROM_ABI iter_type put(iter_type __s, ios_base& __iob, char_type __fl, double __v) const {
        -: 1211:    return do_put(__s, __iob, __fl, __v);
        -: 1212:  }
        -: 1213:
        -: 1214:  _LIBCPP_HIDE_FROM_ABI iter_type put(iter_type __s, ios_base& __iob, char_type __fl, long double __v) const {
        -: 1215:    return do_put(__s, __iob, __fl, __v);
        -: 1216:  }
        -: 1217:
        -: 1218:  _LIBCPP_HIDE_FROM_ABI iter_type put(iter_type __s, ios_base& __iob, char_type __fl, const void* __v) const {
        -: 1219:    return do_put(__s, __iob, __fl, __v);
        -: 1220:  }
        -: 1221:
        -: 1222:  static locale::id id;
        -: 1223:
        -: 1224:protected:
        -: 1225:  _LIBCPP_HIDE_FROM_ABI_VIRTUAL ~num_put() override {}
        -: 1226:
        -: 1227:  virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl, bool __v) const;
        -: 1228:  virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl, long __v) const;
        -: 1229:  virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl, long long __v) const;
        -: 1230:  virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl, unsigned long) const;
        -: 1231:  virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl, unsigned long long) const;
        -: 1232:  virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl, double __v) const;
        -: 1233:  virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl, long double __v) const;
        -: 1234:  virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl, const void* __v) const;
        -: 1235:
        -: 1236:  template <class _Integral>
        -: 1237:  _LIBCPP_HIDE_FROM_ABI inline _OutputIterator
        -: 1238:  __do_put_integral(iter_type __s, ios_base& __iob, char_type __fl, _Integral __v, char const* __len) const;
        -: 1239:
        -: 1240:  template <class _Float>
        -: 1241:  _LIBCPP_HIDE_FROM_ABI inline _OutputIterator
        -: 1242:  __do_put_floating_point(iter_type __s, ios_base& __iob, char_type __fl, _Float __v, char const* __len) const;
        -: 1243:};
        -: 1244:
        -: 1245:template <class _CharT, class _OutputIterator>
        -: 1246:locale::id num_put<_CharT, _OutputIterator>::id;
        -: 1247:
        -: 1248:template <class _CharT, class _OutputIterator>
        -: 1249:_LIBCPP_HIDE_FROM_ABI _OutputIterator __pad_and_output(
        -: 1250:    _OutputIterator __s, const _CharT* __ob, const _CharT* __op, const _CharT* __oe, ios_base& __iob, _CharT __fl) {
        -: 1251:  streamsize __sz = __oe - __ob;
        -: 1252:  streamsize __ns = __iob.width();
        -: 1253:  if (__ns > __sz)
        -: 1254:    __ns -= __sz;
        -: 1255:  else
        -: 1256:    __ns = 0;
        -: 1257:  for (; __ob < __op; ++__ob, ++__s)
        -: 1258:    *__s = *__ob;
        -: 1259:  for (; __ns; --__ns, ++__s)
        -: 1260:    *__s = __fl;
        -: 1261:  for (; __ob < __oe; ++__ob, ++__s)
        -: 1262:    *__s = *__ob;
        -: 1263:  __iob.width(0);
        -: 1264:  return __s;
        -: 1265:}
        -: 1266:
        -: 1267:template <class _CharT, class _Traits>
      976: 1268:_LIBCPP_HIDE_FROM_ABI ostreambuf_iterator<_CharT, _Traits> __pad_and_output(
        -: 1269:    ostreambuf_iterator<_CharT, _Traits> __s,
        -: 1270:    const _CharT* __ob,
        -: 1271:    const _CharT* __op,
        -: 1272:    const _CharT* __oe,
        -: 1273:    ios_base& __iob,
        -: 1274:    _CharT __fl) {
      976: 1275:  if (__s.__sbuf_ == nullptr)
    #####: 1276:    return __s;
      976: 1277:  streamsize __sz = __oe - __ob;
      976: 1278:  streamsize __ns = __iob.width();
      976: 1279:  if (__ns > __sz)
    #####: 1280:    __ns -= __sz;
        -: 1281:  else
      976: 1282:    __ns = 0;
      976: 1283:  streamsize __np = __op - __ob;
      976: 1284:  if (__np > 0) {
    #####: 1285:    if (__s.__sbuf_->sputn(__ob, __np) != __np) {
    #####: 1286:      __s.__sbuf_ = nullptr;
    #####: 1287:      return __s;
        -: 1288:    }
    #####: 1289:  }
      976: 1290:  if (__ns > 0) {
    #####: 1291:    basic_string<_CharT, _Traits> __sp(__ns, __fl);
    #####: 1292:    if (__s.__sbuf_->sputn(__sp.data(), __ns) != __ns) {
    #####: 1293:      __s.__sbuf_ = nullptr;
    #####: 1294:      return __s;
        -: 1295:    }
    #####: 1296:  }
      976: 1297:  __np = __oe - __op;
      976: 1298:  if (__np > 0) {
      976: 1299:    if (__s.__sbuf_->sputn(__op, __np) != __np) {
    #####: 1300:      __s.__sbuf_ = nullptr;
    #####: 1301:      return __s;
        -: 1302:    }
      976: 1303:  }
      976: 1304:  __iob.width(0);
      976: 1305:  return __s;
      976: 1306:}
        -: 1307:
        -: 1308:template <class _CharT, class _OutputIterator>
        -: 1309:_OutputIterator
        -: 1310:num_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob, char_type __fl, bool __v) const {
        -: 1311:  if ((__iob.flags() & ios_base::boolalpha) == 0)
        -: 1312:    return do_put(__s, __iob, __fl, (unsigned long)__v);
        -: 1313:  const numpunct<char_type>& __np = std::use_facet<numpunct<char_type> >(__iob.getloc());
        -: 1314:  typedef typename numpunct<char_type>::string_type string_type;
        -: 1315:  string_type __nm = __v ? __np.truename() : __np.falsename();
        -: 1316:  for (typename string_type::iterator __i = __nm.begin(); __i != __nm.end(); ++__i, ++__s)
        -: 1317:    *__s = *__i;
        -: 1318:  return __s;
        -: 1319:}
        -: 1320:
        -: 1321:template <class _CharT, class _OutputIterator>
        -: 1322:template <class _Integral>
        -: 1323:_LIBCPP_HIDE_FROM_ABI inline _OutputIterator num_put<_CharT, _OutputIterator>::__do_put_integral(
        -: 1324:    iter_type __s, ios_base& __iob, char_type __fl, _Integral __v, char const* __len) const {
        -: 1325:  // Stage 1 - Get number in narrow char
        -: 1326:  char __fmt[8] = {'%', 0};
        -: 1327:  this->__format_int(__fmt + 1, __len, is_signed<_Integral>::value, __iob.flags());
        -: 1328:  // Worst case is octal, with showbase enabled. Note that octal is always
        -: 1329:  // printed as an unsigned value.
        -: 1330:  using _Unsigned = typename make_unsigned<_Integral>::type;
        -: 1331:  _LIBCPP_CONSTEXPR const unsigned __nbuf =
        -: 1332:      (numeric_limits<_Unsigned>::digits / 3)          // 1 char per 3 bits
        -: 1333:      + ((numeric_limits<_Unsigned>::digits % 3) != 0) // round up
        -: 1334:      + 2;                                             // base prefix + terminating null character
        -: 1335:  char __nar[__nbuf];
        -: 1336:  _LIBCPP_DIAGNOSTIC_PUSH
        -: 1337:  _LIBCPP_CLANG_DIAGNOSTIC_IGNORED("-Wformat-nonliteral")
        -: 1338:  _LIBCPP_GCC_DIAGNOSTIC_IGNORED("-Wformat-nonliteral")
        -: 1339:  int __nc = __libcpp_snprintf_l(__nar, sizeof(__nar), _LIBCPP_GET_C_LOCALE, __fmt, __v);
        -: 1340:  _LIBCPP_DIAGNOSTIC_POP
        -: 1341:  char* __ne = __nar + __nc;
        -: 1342:  char* __np = this->__identify_padding(__nar, __ne, __iob);
        -: 1343:  // Stage 2 - Widen __nar while adding thousands separators
        -: 1344:  char_type __o[2 * (__nbuf - 1) - 1];
        -: 1345:  char_type* __op; // pad here
        -: 1346:  char_type* __oe; // end of output
        -: 1347:  this->__widen_and_group_int(__nar, __np, __ne, __o, __op, __oe, __iob.getloc());
        -: 1348:  // [__o, __oe) contains thousands_sep'd wide number
        -: 1349:  // Stage 3 & 4
        -: 1350:  return std::__pad_and_output(__s, __o, __op, __oe, __iob, __fl);
        -: 1351:}
        -: 1352:
        -: 1353:template <class _CharT, class _OutputIterator>
        -: 1354:_OutputIterator
        -: 1355:num_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob, char_type __fl, long __v) const {
        -: 1356:  return this->__do_put_integral(__s, __iob, __fl, __v, "l");
        -: 1357:}
        -: 1358:
        -: 1359:template <class _CharT, class _OutputIterator>
        -: 1360:_OutputIterator
        -: 1361:num_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob, char_type __fl, long long __v) const {
        -: 1362:  return this->__do_put_integral(__s, __iob, __fl, __v, "ll");
        -: 1363:}
        -: 1364:
        -: 1365:template <class _CharT, class _OutputIterator>
        -: 1366:_OutputIterator
        -: 1367:num_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob, char_type __fl, unsigned long __v) const {
        -: 1368:  return this->__do_put_integral(__s, __iob, __fl, __v, "l");
        -: 1369:}
        -: 1370:
        -: 1371:template <class _CharT, class _OutputIterator>
        -: 1372:_OutputIterator
        -: 1373:num_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob, char_type __fl, unsigned long long __v) const {
        -: 1374:  return this->__do_put_integral(__s, __iob, __fl, __v, "ll");
        -: 1375:}
        -: 1376:
        -: 1377:template <class _CharT, class _OutputIterator>
        -: 1378:template <class _Float>
        -: 1379:_LIBCPP_HIDE_FROM_ABI inline _OutputIterator num_put<_CharT, _OutputIterator>::__do_put_floating_point(
        -: 1380:    iter_type __s, ios_base& __iob, char_type __fl, _Float __v, char const* __len) const {
        -: 1381:  // Stage 1 - Get number in narrow char
        -: 1382:  char __fmt[8]            = {'%', 0};
        -: 1383:  bool __specify_precision = this->__format_float(__fmt + 1, __len, __iob.flags());
        -: 1384:  const unsigned __nbuf    = 30;
        -: 1385:  char __nar[__nbuf];
        -: 1386:  char* __nb = __nar;
        -: 1387:  int __nc;
        -: 1388:  _LIBCPP_DIAGNOSTIC_PUSH
        -: 1389:  _LIBCPP_CLANG_DIAGNOSTIC_IGNORED("-Wformat-nonliteral")
        -: 1390:  _LIBCPP_GCC_DIAGNOSTIC_IGNORED("-Wformat-nonliteral")
        -: 1391:  if (__specify_precision)
        -: 1392:    __nc = __libcpp_snprintf_l(__nb, __nbuf, _LIBCPP_GET_C_LOCALE, __fmt, (int)__iob.precision(), __v);
        -: 1393:  else
        -: 1394:    __nc = __libcpp_snprintf_l(__nb, __nbuf, _LIBCPP_GET_C_LOCALE, __fmt, __v);
        -: 1395:  unique_ptr<char, void (*)(void*)> __nbh(nullptr, free);
        -: 1396:  if (__nc > static_cast<int>(__nbuf - 1)) {
        -: 1397:    if (__specify_precision)
        -: 1398:      __nc = __libcpp_asprintf_l(&__nb, _LIBCPP_GET_C_LOCALE, __fmt, (int)__iob.precision(), __v);
        -: 1399:    else
        -: 1400:      __nc = __libcpp_asprintf_l(&__nb, _LIBCPP_GET_C_LOCALE, __fmt, __v);
        -: 1401:    if (__nc == -1)
        -: 1402:      __throw_bad_alloc();
        -: 1403:    __nbh.reset(__nb);
        -: 1404:  }
        -: 1405:  _LIBCPP_DIAGNOSTIC_POP
        -: 1406:  char* __ne = __nb + __nc;
        -: 1407:  char* __np = this->__identify_padding(__nb, __ne, __iob);
        -: 1408:  // Stage 2 - Widen __nar while adding thousands separators
        -: 1409:  char_type __o[2 * (__nbuf - 1) - 1];
        -: 1410:  char_type* __ob = __o;
        -: 1411:  unique_ptr<char_type, void (*)(void*)> __obh(0, free);
        -: 1412:  if (__nb != __nar) {
        -: 1413:    __ob = (char_type*)malloc(2 * static_cast<size_t>(__nc) * sizeof(char_type));
        -: 1414:    if (__ob == 0)
        -: 1415:      __throw_bad_alloc();
        -: 1416:    __obh.reset(__ob);
        -: 1417:  }
        -: 1418:  char_type* __op; // pad here
        -: 1419:  char_type* __oe; // end of output
        -: 1420:  this->__widen_and_group_float(__nb, __np, __ne, __ob, __op, __oe, __iob.getloc());
        -: 1421:  // [__o, __oe) contains thousands_sep'd wide number
        -: 1422:  // Stage 3 & 4
        -: 1423:  __s = std::__pad_and_output(__s, __ob, __op, __oe, __iob, __fl);
        -: 1424:  return __s;
        -: 1425:}
        -: 1426:
        -: 1427:template <class _CharT, class _OutputIterator>
        -: 1428:_OutputIterator
        -: 1429:num_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob, char_type __fl, double __v) const {
        -: 1430:  return this->__do_put_floating_point(__s, __iob, __fl, __v, "");
        -: 1431:}
        -: 1432:
        -: 1433:template <class _CharT, class _OutputIterator>
        -: 1434:_OutputIterator
        -: 1435:num_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob, char_type __fl, long double __v) const {
        -: 1436:  return this->__do_put_floating_point(__s, __iob, __fl, __v, "L");
        -: 1437:}
        -: 1438:
        -: 1439:template <class _CharT, class _OutputIterator>
        -: 1440:_OutputIterator
        -: 1441:num_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob, char_type __fl, const void* __v) const {
        -: 1442:  // Stage 1 - Get pointer in narrow char
        -: 1443:  const unsigned __nbuf = 20;
        -: 1444:  char __nar[__nbuf];
        -: 1445:  int __nc   = __libcpp_snprintf_l(__nar, sizeof(__nar), _LIBCPP_GET_C_LOCALE, "%p", __v);
        -: 1446:  char* __ne = __nar + __nc;
        -: 1447:  char* __np = this->__identify_padding(__nar, __ne, __iob);
        -: 1448:  // Stage 2 - Widen __nar
        -: 1449:  char_type __o[2 * (__nbuf - 1) - 1];
        -: 1450:  char_type* __op; // pad here
        -: 1451:  char_type* __oe; // end of output
        -: 1452:  const ctype<char_type>& __ct = std::use_facet<ctype<char_type> >(__iob.getloc());
        -: 1453:  __ct.widen(__nar, __ne, __o);
        -: 1454:  __oe = __o + (__ne - __nar);
        -: 1455:  if (__np == __ne)
        -: 1456:    __op = __oe;
        -: 1457:  else
        -: 1458:    __op = __o + (__np - __nar);
        -: 1459:  // [__o, __oe) contains wide number
        -: 1460:  // Stage 3 & 4
        -: 1461:  return std::__pad_and_output(__s, __o, __op, __oe, __iob, __fl);
        -: 1462:}
        -: 1463:
        -: 1464:extern template class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS num_put<char>;
        -: 1465:#  ifndef _LIBCPP_HAS_NO_WIDE_CHARACTERS
        -: 1466:extern template class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS num_put<wchar_t>;
        -: 1467:#  endif
        -: 1468:
        -: 1469:template <class _CharT, class _InputIterator>
        -: 1470:_LIBCPP_HIDE_FROM_ABI int __get_up_to_n_digits(
        -: 1471:    _InputIterator& __b, _InputIterator __e, ios_base::iostate& __err, const ctype<_CharT>& __ct, int __n) {
        -: 1472:  // Precondition:  __n >= 1
        -: 1473:  if (__b == __e) {
        -: 1474:    __err |= ios_base::eofbit | ios_base::failbit;
        -: 1475:    return 0;
        -: 1476:  }
        -: 1477:  // get first digit
        -: 1478:  _CharT __c = *__b;
        -: 1479:  if (!__ct.is(ctype_base::digit, __c)) {
        -: 1480:    __err |= ios_base::failbit;
        -: 1481:    return 0;
        -: 1482:  }
        -: 1483:  int __r = __ct.narrow(__c, 0) - '0';
        -: 1484:  for (++__b, (void)--__n; __b != __e && __n > 0; ++__b, (void)--__n) {
        -: 1485:    // get next digit
        -: 1486:    __c = *__b;
        -: 1487:    if (!__ct.is(ctype_base::digit, __c))
        -: 1488:      return __r;
        -: 1489:    __r = __r * 10 + __ct.narrow(__c, 0) - '0';
        -: 1490:  }
        -: 1491:  if (__b == __e)
        -: 1492:    __err |= ios_base::eofbit;
        -: 1493:  return __r;
        -: 1494:}
        -: 1495:
        -: 1496:class _LIBCPP_EXPORTED_FROM_ABI time_base {
        -: 1497:public:
        -: 1498:  enum dateorder { no_order, dmy, mdy, ymd, ydm };
        -: 1499:};
        -: 1500:
        -: 1501:template <class _CharT>
        -: 1502:class _LIBCPP_TEMPLATE_VIS __time_get_c_storage {
        -: 1503:protected:
        -: 1504:  typedef basic_string<_CharT> string_type;
        -: 1505:
        -: 1506:  virtual const string_type* __weeks() const;
        -: 1507:  virtual const string_type* __months() const;
        -: 1508:  virtual const string_type* __am_pm() const;
        -: 1509:  virtual const string_type& __c() const;
        -: 1510:  virtual const string_type& __r() const;
        -: 1511:  virtual const string_type& __x() const;
        -: 1512:  virtual const string_type& __X() const;
        -: 1513:
        -: 1514:  _LIBCPP_HIDE_FROM_ABI ~__time_get_c_storage() {}
        -: 1515:};
        -: 1516:
        -: 1517:template <>
        -: 1518:_LIBCPP_EXPORTED_FROM_ABI const string* __time_get_c_storage<char>::__weeks() const;
        -: 1519:template <>
        -: 1520:_LIBCPP_EXPORTED_FROM_ABI const string* __time_get_c_storage<char>::__months() const;
        -: 1521:template <>
        -: 1522:_LIBCPP_EXPORTED_FROM_ABI const string* __time_get_c_storage<char>::__am_pm() const;
        -: 1523:template <>
        -: 1524:_LIBCPP_EXPORTED_FROM_ABI const string& __time_get_c_storage<char>::__c() const;
        -: 1525:template <>
        -: 1526:_LIBCPP_EXPORTED_FROM_ABI const string& __time_get_c_storage<char>::__r() const;
        -: 1527:template <>
        -: 1528:_LIBCPP_EXPORTED_FROM_ABI const string& __time_get_c_storage<char>::__x() const;
        -: 1529:template <>
        -: 1530:_LIBCPP_EXPORTED_FROM_ABI const string& __time_get_c_storage<char>::__X() const;
        -: 1531:
        -: 1532:#  ifndef _LIBCPP_HAS_NO_WIDE_CHARACTERS
        -: 1533:template <>
        -: 1534:_LIBCPP_EXPORTED_FROM_ABI const wstring* __time_get_c_storage<wchar_t>::__weeks() const;
        -: 1535:template <>
        -: 1536:_LIBCPP_EXPORTED_FROM_ABI const wstring* __time_get_c_storage<wchar_t>::__months() const;
        -: 1537:template <>
        -: 1538:_LIBCPP_EXPORTED_FROM_ABI const wstring* __time_get_c_storage<wchar_t>::__am_pm() const;
        -: 1539:template <>
        -: 1540:_LIBCPP_EXPORTED_FROM_ABI const wstring& __time_get_c_storage<wchar_t>::__c() const;
        -: 1541:template <>
        -: 1542:_LIBCPP_EXPORTED_FROM_ABI const wstring& __time_get_c_storage<wchar_t>::__r() const;
        -: 1543:template <>
        -: 1544:_LIBCPP_EXPORTED_FROM_ABI const wstring& __time_get_c_storage<wchar_t>::__x() const;
        -: 1545:template <>
        -: 1546:_LIBCPP_EXPORTED_FROM_ABI const wstring& __time_get_c_storage<wchar_t>::__X() const;
        -: 1547:#  endif
        -: 1548:
        -: 1549:template <class _CharT, class _InputIterator = istreambuf_iterator<_CharT> >
        -: 1550:class _LIBCPP_TEMPLATE_VIS time_get : public locale::facet, public time_base, private __time_get_c_storage<_CharT> {
        -: 1551:public:
        -: 1552:  typedef _CharT char_type;
        -: 1553:  typedef _InputIterator iter_type;
        -: 1554:  typedef time_base::dateorder dateorder;
        -: 1555:  typedef basic_string<char_type> string_type;
        -: 1556:
        -: 1557:  _LIBCPP_HIDE_FROM_ABI explicit time_get(size_t __refs = 0) : locale::facet(__refs) {}
        -: 1558:
        -: 1559:  _LIBCPP_HIDE_FROM_ABI dateorder date_order() const { return this->do_date_order(); }
        -: 1560:
        -: 1561:  _LIBCPP_HIDE_FROM_ABI iter_type
        -: 1562:  get_time(iter_type __b, iter_type __e, ios_base& __iob, ios_base::iostate& __err, tm* __tm) const {
        -: 1563:    return do_get_time(__b, __e, __iob, __err, __tm);
        -: 1564:  }
        -: 1565:
        -: 1566:  _LIBCPP_HIDE_FROM_ABI iter_type
        -: 1567:  get_date(iter_type __b, iter_type __e, ios_base& __iob, ios_base::iostate& __err, tm* __tm) const {
        -: 1568:    return do_get_date(__b, __e, __iob, __err, __tm);
        -: 1569:  }
        -: 1570:
        -: 1571:  _LIBCPP_HIDE_FROM_ABI iter_type
        -: 1572:  get_weekday(iter_type __b, iter_type __e, ios_base& __iob, ios_base::iostate& __err, tm* __tm) const {
        -: 1573:    return do_get_weekday(__b, __e, __iob, __err, __tm);
        -: 1574:  }
        -: 1575:
        -: 1576:  _LIBCPP_HIDE_FROM_ABI iter_type
        -: 1577:  get_monthname(iter_type __b, iter_type __e, ios_base& __iob, ios_base::iostate& __err, tm* __tm) const {
        -: 1578:    return do_get_monthname(__b, __e, __iob, __err, __tm);
        -: 1579:  }
        -: 1580:
        -: 1581:  _LIBCPP_HIDE_FROM_ABI iter_type
        -: 1582:  get_year(iter_type __b, iter_type __e, ios_base& __iob, ios_base::iostate& __err, tm* __tm) const {
        -: 1583:    return do_get_year(__b, __e, __iob, __err, __tm);
        -: 1584:  }
        -: 1585:
        -: 1586:  _LIBCPP_HIDE_FROM_ABI iter_type
        -: 1587:  get(iter_type __b, iter_type __e, ios_base& __iob, ios_base::iostate& __err, tm* __tm, char __fmt, char __mod = 0)
        -: 1588:      const {
        -: 1589:    return do_get(__b, __e, __iob, __err, __tm, __fmt, __mod);
        -: 1590:  }
        -: 1591:
        -: 1592:  iter_type
        -: 1593:  get(iter_type __b,
        -: 1594:      iter_type __e,
        -: 1595:      ios_base& __iob,
        -: 1596:      ios_base::iostate& __err,
        -: 1597:      tm* __tm,
        -: 1598:      const char_type* __fmtb,
        -: 1599:      const char_type* __fmte) const;
        -: 1600:
        -: 1601:  static locale::id id;
        -: 1602:
        -: 1603:protected:
        -: 1604:  _LIBCPP_HIDE_FROM_ABI_VIRTUAL ~time_get() override {}
        -: 1605:
        -: 1606:  virtual dateorder do_date_order() const;
        -: 1607:  virtual iter_type
        -: 1608:  do_get_time(iter_type __b, iter_type __e, ios_base& __iob, ios_base::iostate& __err, tm* __tm) const;
        -: 1609:  virtual iter_type
        -: 1610:  do_get_date(iter_type __b, iter_type __e, ios_base& __iob, ios_base::iostate& __err, tm* __tm) const;
        -: 1611:  virtual iter_type
        -: 1612:  do_get_weekday(iter_type __b, iter_type __e, ios_base& __iob, ios_base::iostate& __err, tm* __tm) const;
        -: 1613:  virtual iter_type
        -: 1614:  do_get_monthname(iter_type __b, iter_type __e, ios_base& __iob, ios_base::iostate& __err, tm* __tm) const;
        -: 1615:  virtual iter_type
        -: 1616:  do_get_year(iter_type __b, iter_type __e, ios_base& __iob, ios_base::iostate& __err, tm* __tm) const;
        -: 1617:  virtual iter_type do_get(
        -: 1618:      iter_type __b, iter_type __e, ios_base& __iob, ios_base::iostate& __err, tm* __tm, char __fmt, char __mod) const;
        -: 1619:
        -: 1620:private:
        -: 1621:  void __get_white_space(iter_type& __b, iter_type __e, ios_base::iostate& __err, const ctype<char_type>& __ct) const;
        -: 1622:  void __get_percent(iter_type& __b, iter_type __e, ios_base::iostate& __err, const ctype<char_type>& __ct) const;
        -: 1623:
        -: 1624:  void __get_weekdayname(
        -: 1625:      int& __m, iter_type& __b, iter_type __e, ios_base::iostate& __err, const ctype<char_type>& __ct) const;
        -: 1626:  void __get_monthname(
        -: 1627:      int& __m, iter_type& __b, iter_type __e, ios_base::iostate& __err, const ctype<char_type>& __ct) const;
        -: 1628:  void __get_day(int& __d, iter_type& __b, iter_type __e, ios_base::iostate& __err, const ctype<char_type>& __ct) const;
        -: 1629:  void
        -: 1630:  __get_month(int& __m, iter_type& __b, iter_type __e, ios_base::iostate& __err, const ctype<char_type>& __ct) const;
        -: 1631:  void
        -: 1632:  __get_year(int& __y, iter_type& __b, iter_type __e, ios_base::iostate& __err, const ctype<char_type>& __ct) const;
        -: 1633:  void
        -: 1634:  __get_year4(int& __y, iter_type& __b, iter_type __e, ios_base::iostate& __err, const ctype<char_type>& __ct) const;
        -: 1635:  void
        -: 1636:  __get_hour(int& __d, iter_type& __b, iter_type __e, ios_base::iostate& __err, const ctype<char_type>& __ct) const;
        -: 1637:  void
        -: 1638:  __get_12_hour(int& __h, iter_type& __b, iter_type __e, ios_base::iostate& __err, const ctype<char_type>& __ct) const;
        -: 1639:  void
        -: 1640:  __get_am_pm(int& __h, iter_type& __b, iter_type __e, ios_base::iostate& __err, const ctype<char_type>& __ct) const;
        -: 1641:  void
        -: 1642:  __get_minute(int& __m, iter_type& __b, iter_type __e, ios_base::iostate& __err, const ctype<char_type>& __ct) const;
        -: 1643:  void
        -: 1644:  __get_second(int& __s, iter_type& __b, iter_type __e, ios_base::iostate& __err, const ctype<char_type>& __ct) const;
        -: 1645:  void
        -: 1646:  __get_weekday(int& __w, iter_type& __b, iter_type __e, ios_base::iostate& __err, const ctype<char_type>& __ct) const;
        -: 1647:  void __get_day_year_num(
        -: 1648:      int& __w, iter_type& __b, iter_type __e, ios_base::iostate& __err, const ctype<char_type>& __ct) const;
        -: 1649:};
        -: 1650:
        -: 1651:template <class _CharT, class _InputIterator>
        -: 1652:locale::id time_get<_CharT, _InputIterator>::id;
        -: 1653:
        -: 1654:// time_get primitives
        -: 1655:
        -: 1656:template <class _CharT, class _InputIterator>
        -: 1657:void time_get<_CharT, _InputIterator>::__get_weekdayname(
        -: 1658:    int& __w, iter_type& __b, iter_type __e, ios_base::iostate& __err, const ctype<char_type>& __ct) const {
        -: 1659:  // Note:  ignoring case comes from the POSIX strptime spec
        -: 1660:  const string_type* __wk = this->__weeks();
        -: 1661:  ptrdiff_t __i           = std::__scan_keyword(__b, __e, __wk, __wk + 14, __ct, __err, false) - __wk;
        -: 1662:  if (__i < 14)
        -: 1663:    __w = __i % 7;
        -: 1664:}
        -: 1665:
        -: 1666:template <class _CharT, class _InputIterator>
        -: 1667:void time_get<_CharT, _InputIterator>::__get_monthname(
        -: 1668:    int& __m, iter_type& __b, iter_type __e, ios_base::iostate& __err, const ctype<char_type>& __ct) const {
        -: 1669:  // Note:  ignoring case comes from the POSIX strptime spec
        -: 1670:  const string_type* __month = this->__months();
        -: 1671:  ptrdiff_t __i              = std::__scan_keyword(__b, __e, __month, __month + 24, __ct, __err, false) - __month;
        -: 1672:  if (__i < 24)
        -: 1673:    __m = __i % 12;
        -: 1674:}
        -: 1675:
        -: 1676:template <class _CharT, class _InputIterator>
        -: 1677:void time_get<_CharT, _InputIterator>::__get_day(
        -: 1678:    int& __d, iter_type& __b, iter_type __e, ios_base::iostate& __err, const ctype<char_type>& __ct) const {
        -: 1679:  int __t = std::__get_up_to_n_digits(__b, __e, __err, __ct, 2);
        -: 1680:  if (!(__err & ios_base::failbit) && 1 <= __t && __t <= 31)
        -: 1681:    __d = __t;
        -: 1682:  else
        -: 1683:    __err |= ios_base::failbit;
        -: 1684:}
        -: 1685:
        -: 1686:template <class _CharT, class _InputIterator>
        -: 1687:void time_get<_CharT, _InputIterator>::__get_month(
        -: 1688:    int& __m, iter_type& __b, iter_type __e, ios_base::iostate& __err, const ctype<char_type>& __ct) const {
        -: 1689:  int __t = std::__get_up_to_n_digits(__b, __e, __err, __ct, 2) - 1;
        -: 1690:  if (!(__err & ios_base::failbit) && 0 <= __t && __t <= 11)
        -: 1691:    __m = __t;
        -: 1692:  else
        -: 1693:    __err |= ios_base::failbit;
        -: 1694:}
        -: 1695:
        -: 1696:template <class _CharT, class _InputIterator>
        -: 1697:void time_get<_CharT, _InputIterator>::__get_year(
        -: 1698:    int& __y, iter_type& __b, iter_type __e, ios_base::iostate& __err, const ctype<char_type>& __ct) const {
        -: 1699:  int __t = std::__get_up_to_n_digits(__b, __e, __err, __ct, 4);
        -: 1700:  if (!(__err & ios_base::failbit)) {
        -: 1701:    if (__t < 69)
        -: 1702:      __t += 2000;
        -: 1703:    else if (69 <= __t && __t <= 99)
        -: 1704:      __t += 1900;
        -: 1705:    __y = __t - 1900;
        -: 1706:  }
        -: 1707:}
        -: 1708:
        -: 1709:template <class _CharT, class _InputIterator>
        -: 1710:void time_get<_CharT, _InputIterator>::__get_year4(
        -: 1711:    int& __y, iter_type& __b, iter_type __e, ios_base::iostate& __err, const ctype<char_type>& __ct) const {
        -: 1712:  int __t = std::__get_up_to_n_digits(__b, __e, __err, __ct, 4);
        -: 1713:  if (!(__err & ios_base::failbit))
        -: 1714:    __y = __t - 1900;
        -: 1715:}
        -: 1716:
        -: 1717:template <class _CharT, class _InputIterator>
        -: 1718:void time_get<_CharT, _InputIterator>::__get_hour(
        -: 1719:    int& __h, iter_type& __b, iter_type __e, ios_base::iostate& __err, const ctype<char_type>& __ct) const {
        -: 1720:  int __t = std::__get_up_to_n_digits(__b, __e, __err, __ct, 2);
        -: 1721:  if (!(__err & ios_base::failbit) && __t <= 23)
        -: 1722:    __h = __t;
        -: 1723:  else
        -: 1724:    __err |= ios_base::failbit;
        -: 1725:}
        -: 1726:
        -: 1727:template <class _CharT, class _InputIterator>
        -: 1728:void time_get<_CharT, _InputIterator>::__get_12_hour(
        -: 1729:    int& __h, iter_type& __b, iter_type __e, ios_base::iostate& __err, const ctype<char_type>& __ct) const {
        -: 1730:  int __t = std::__get_up_to_n_digits(__b, __e, __err, __ct, 2);
        -: 1731:  if (!(__err & ios_base::failbit) && 1 <= __t && __t <= 12)
        -: 1732:    __h = __t;
        -: 1733:  else
        -: 1734:    __err |= ios_base::failbit;
        -: 1735:}
        -: 1736:
        -: 1737:template <class _CharT, class _InputIterator>
        -: 1738:void time_get<_CharT, _InputIterator>::__get_minute(
        -: 1739:    int& __m, iter_type& __b, iter_type __e, ios_base::iostate& __err, const ctype<char_type>& __ct) const {
        -: 1740:  int __t = std::__get_up_to_n_digits(__b, __e, __err, __ct, 2);
        -: 1741:  if (!(__err & ios_base::failbit) && __t <= 59)
        -: 1742:    __m = __t;
        -: 1743:  else
        -: 1744:    __err |= ios_base::failbit;
        -: 1745:}
        -: 1746:
        -: 1747:template <class _CharT, class _InputIterator>
        -: 1748:void time_get<_CharT, _InputIterator>::__get_second(
        -: 1749:    int& __s, iter_type& __b, iter_type __e, ios_base::iostate& __err, const ctype<char_type>& __ct) const {
        -: 1750:  int __t = std::__get_up_to_n_digits(__b, __e, __err, __ct, 2);
        -: 1751:  if (!(__err & ios_base::failbit) && __t <= 60)
        -: 1752:    __s = __t;
        -: 1753:  else
        -: 1754:    __err |= ios_base::failbit;
        -: 1755:}
        -: 1756:
        -: 1757:template <class _CharT, class _InputIterator>
        -: 1758:void time_get<_CharT, _InputIterator>::__get_weekday(
        -: 1759:    int& __w, iter_type& __b, iter_type __e, ios_base::iostate& __err, const ctype<char_type>& __ct) const {
        -: 1760:  int __t = std::__get_up_to_n_digits(__b, __e, __err, __ct, 1);
        -: 1761:  if (!(__err & ios_base::failbit) && __t <= 6)
        -: 1762:    __w = __t;
        -: 1763:  else
        -: 1764:    __err |= ios_base::failbit;
        -: 1765:}
        -: 1766:
        -: 1767:template <class _CharT, class _InputIterator>
        -: 1768:void time_get<_CharT, _InputIterator>::__get_day_year_num(
        -: 1769:    int& __d, iter_type& __b, iter_type __e, ios_base::iostate& __err, const ctype<char_type>& __ct) const {
        -: 1770:  int __t = std::__get_up_to_n_digits(__b, __e, __err, __ct, 3);
        -: 1771:  if (!(__err & ios_base::failbit) && __t <= 365)
        -: 1772:    __d = __t;
        -: 1773:  else
        -: 1774:    __err |= ios_base::failbit;
        -: 1775:}
        -: 1776:
        -: 1777:template <class _CharT, class _InputIterator>
        -: 1778:void time_get<_CharT, _InputIterator>::__get_white_space(
        -: 1779:    iter_type& __b, iter_type __e, ios_base::iostate& __err, const ctype<char_type>& __ct) const {
        -: 1780:  for (; __b != __e && __ct.is(ctype_base::space, *__b); ++__b)
        -: 1781:    ;
        -: 1782:  if (__b == __e)
        -: 1783:    __err |= ios_base::eofbit;
        -: 1784:}
        -: 1785:
        -: 1786:template <class _CharT, class _InputIterator>
        -: 1787:void time_get<_CharT, _InputIterator>::__get_am_pm(
        -: 1788:    int& __h, iter_type& __b, iter_type __e, ios_base::iostate& __err, const ctype<char_type>& __ct) const {
        -: 1789:  const string_type* __ap = this->__am_pm();
        -: 1790:  if (__ap[0].size() + __ap[1].size() == 0) {
        -: 1791:    __err |= ios_base::failbit;
        -: 1792:    return;
        -: 1793:  }
        -: 1794:  ptrdiff_t __i = std::__scan_keyword(__b, __e, __ap, __ap + 2, __ct, __err, false) - __ap;
        -: 1795:  if (__i == 0 && __h == 12)
        -: 1796:    __h = 0;
        -: 1797:  else if (__i == 1 && __h < 12)
        -: 1798:    __h += 12;
        -: 1799:}
        -: 1800:
        -: 1801:template <class _CharT, class _InputIterator>
        -: 1802:void time_get<_CharT, _InputIterator>::__get_percent(
        -: 1803:    iter_type& __b, iter_type __e, ios_base::iostate& __err, const ctype<char_type>& __ct) const {
        -: 1804:  if (__b == __e) {
        -: 1805:    __err |= ios_base::eofbit | ios_base::failbit;
        -: 1806:    return;
        -: 1807:  }
        -: 1808:  if (__ct.narrow(*__b, 0) != '%')
        -: 1809:    __err |= ios_base::failbit;
        -: 1810:  else if (++__b == __e)
        -: 1811:    __err |= ios_base::eofbit;
        -: 1812:}
        -: 1813:
        -: 1814:// time_get end primitives
        -: 1815:
        -: 1816:template <class _CharT, class _InputIterator>
        -: 1817:_InputIterator time_get<_CharT, _InputIterator>::get(
        -: 1818:    iter_type __b,
        -: 1819:    iter_type __e,
        -: 1820:    ios_base& __iob,
        -: 1821:    ios_base::iostate& __err,
        -: 1822:    tm* __tm,
        -: 1823:    const char_type* __fmtb,
        -: 1824:    const char_type* __fmte) const {
        -: 1825:  const ctype<char_type>& __ct = std::use_facet<ctype<char_type> >(__iob.getloc());
        -: 1826:  __err                        = ios_base::goodbit;
        -: 1827:  while (__fmtb != __fmte && __err == ios_base::goodbit) {
        -: 1828:    if (__b == __e) {
        -: 1829:      __err = ios_base::failbit;
        -: 1830:      break;
        -: 1831:    }
        -: 1832:    if (__ct.narrow(*__fmtb, 0) == '%') {
        -: 1833:      if (++__fmtb == __fmte) {
        -: 1834:        __err = ios_base::failbit;
        -: 1835:        break;
        -: 1836:      }
        -: 1837:      char __cmd = __ct.narrow(*__fmtb, 0);
        -: 1838:      char __opt = '\0';
        -: 1839:      if (__cmd == 'E' || __cmd == '0') {
        -: 1840:        if (++__fmtb == __fmte) {
        -: 1841:          __err = ios_base::failbit;
        -: 1842:          break;
        -: 1843:        }
        -: 1844:        __opt = __cmd;
        -: 1845:        __cmd = __ct.narrow(*__fmtb, 0);
        -: 1846:      }
        -: 1847:      __b = do_get(__b, __e, __iob, __err, __tm, __cmd, __opt);
        -: 1848:      ++__fmtb;
        -: 1849:    } else if (__ct.is(ctype_base::space, *__fmtb)) {
        -: 1850:      for (++__fmtb; __fmtb != __fmte && __ct.is(ctype_base::space, *__fmtb); ++__fmtb)
        -: 1851:        ;
        -: 1852:      for (; __b != __e && __ct.is(ctype_base::space, *__b); ++__b)
        -: 1853:        ;
        -: 1854:    } else if (__ct.toupper(*__b) == __ct.toupper(*__fmtb)) {
        -: 1855:      ++__b;
        -: 1856:      ++__fmtb;
        -: 1857:    } else
        -: 1858:      __err = ios_base::failbit;
        -: 1859:  }
        -: 1860:  if (__b == __e)
        -: 1861:    __err |= ios_base::eofbit;
        -: 1862:  return __b;
        -: 1863:}
        -: 1864:
        -: 1865:template <class _CharT, class _InputIterator>
        -: 1866:typename time_get<_CharT, _InputIterator>::dateorder time_get<_CharT, _InputIterator>::do_date_order() const {
        -: 1867:  return mdy;
        -: 1868:}
        -: 1869:
        -: 1870:template <class _CharT, class _InputIterator>
        -: 1871:_InputIterator time_get<_CharT, _InputIterator>::do_get_time(
        -: 1872:    iter_type __b, iter_type __e, ios_base& __iob, ios_base::iostate& __err, tm* __tm) const {
        -: 1873:  const char_type __fmt[] = {'%', 'H', ':', '%', 'M', ':', '%', 'S'};
        -: 1874:  return get(__b, __e, __iob, __err, __tm, __fmt, __fmt + sizeof(__fmt) / sizeof(__fmt[0]));
        -: 1875:}
        -: 1876:
        -: 1877:template <class _CharT, class _InputIterator>
        -: 1878:_InputIterator time_get<_CharT, _InputIterator>::do_get_date(
        -: 1879:    iter_type __b, iter_type __e, ios_base& __iob, ios_base::iostate& __err, tm* __tm) const {
        -: 1880:  const string_type& __fmt = this->__x();
        -: 1881:  return get(__b, __e, __iob, __err, __tm, __fmt.data(), __fmt.data() + __fmt.size());
        -: 1882:}
        -: 1883:
        -: 1884:template <class _CharT, class _InputIterator>
        -: 1885:_InputIterator time_get<_CharT, _InputIterator>::do_get_weekday(
        -: 1886:    iter_type __b, iter_type __e, ios_base& __iob, ios_base::iostate& __err, tm* __tm) const {
        -: 1887:  const ctype<char_type>& __ct = std::use_facet<ctype<char_type> >(__iob.getloc());
        -: 1888:  __get_weekdayname(__tm->tm_wday, __b, __e, __err, __ct);
        -: 1889:  return __b;
        -: 1890:}
        -: 1891:
        -: 1892:template <class _CharT, class _InputIterator>
        -: 1893:_InputIterator time_get<_CharT, _InputIterator>::do_get_monthname(
        -: 1894:    iter_type __b, iter_type __e, ios_base& __iob, ios_base::iostate& __err, tm* __tm) const {
        -: 1895:  const ctype<char_type>& __ct = std::use_facet<ctype<char_type> >(__iob.getloc());
        -: 1896:  __get_monthname(__tm->tm_mon, __b, __e, __err, __ct);
        -: 1897:  return __b;
        -: 1898:}
        -: 1899:
        -: 1900:template <class _CharT, class _InputIterator>
        -: 1901:_InputIterator time_get<_CharT, _InputIterator>::do_get_year(
        -: 1902:    iter_type __b, iter_type __e, ios_base& __iob, ios_base::iostate& __err, tm* __tm) const {
        -: 1903:  const ctype<char_type>& __ct = std::use_facet<ctype<char_type> >(__iob.getloc());
        -: 1904:  __get_year(__tm->tm_year, __b, __e, __err, __ct);
        -: 1905:  return __b;
        -: 1906:}
        -: 1907:
        -: 1908:template <class _CharT, class _InputIterator>
        -: 1909:_InputIterator time_get<_CharT, _InputIterator>::do_get(
        -: 1910:    iter_type __b, iter_type __e, ios_base& __iob, ios_base::iostate& __err, tm* __tm, char __fmt, char) const {
        -: 1911:  __err                        = ios_base::goodbit;
        -: 1912:  const ctype<char_type>& __ct = std::use_facet<ctype<char_type> >(__iob.getloc());
        -: 1913:  switch (__fmt) {
        -: 1914:  case 'a':
        -: 1915:  case 'A':
        -: 1916:    __get_weekdayname(__tm->tm_wday, __b, __e, __err, __ct);
        -: 1917:    break;
        -: 1918:  case 'b':
        -: 1919:  case 'B':
        -: 1920:  case 'h':
        -: 1921:    __get_monthname(__tm->tm_mon, __b, __e, __err, __ct);
        -: 1922:    break;
        -: 1923:  case 'c': {
        -: 1924:    const string_type& __fm = this->__c();
        -: 1925:    __b                     = get(__b, __e, __iob, __err, __tm, __fm.data(), __fm.data() + __fm.size());
        -: 1926:  } break;
        -: 1927:  case 'd':
        -: 1928:  case 'e':
        -: 1929:    __get_day(__tm->tm_mday, __b, __e, __err, __ct);
        -: 1930:    break;
        -: 1931:  case 'D': {
        -: 1932:    const char_type __fm[] = {'%', 'm', '/', '%', 'd', '/', '%', 'y'};
        -: 1933:    __b                    = get(__b, __e, __iob, __err, __tm, __fm, __fm + sizeof(__fm) / sizeof(__fm[0]));
        -: 1934:  } break;
        -: 1935:  case 'F': {
        -: 1936:    const char_type __fm[] = {'%', 'Y', '-', '%', 'm', '-', '%', 'd'};
        -: 1937:    __b                    = get(__b, __e, __iob, __err, __tm, __fm, __fm + sizeof(__fm) / sizeof(__fm[0]));
        -: 1938:  } break;
        -: 1939:  case 'H':
        -: 1940:    __get_hour(__tm->tm_hour, __b, __e, __err, __ct);
        -: 1941:    break;
        -: 1942:  case 'I':
        -: 1943:    __get_12_hour(__tm->tm_hour, __b, __e, __err, __ct);
        -: 1944:    break;
        -: 1945:  case 'j':
        -: 1946:    __get_day_year_num(__tm->tm_yday, __b, __e, __err, __ct);
        -: 1947:    break;
        -: 1948:  case 'm':
        -: 1949:    __get_month(__tm->tm_mon, __b, __e, __err, __ct);
        -: 1950:    break;
        -: 1951:  case 'M':
        -: 1952:    __get_minute(__tm->tm_min, __b, __e, __err, __ct);
        -: 1953:    break;
        -: 1954:  case 'n':
        -: 1955:  case 't':
        -: 1956:    __get_white_space(__b, __e, __err, __ct);
        -: 1957:    break;
        -: 1958:  case 'p':
        -: 1959:    __get_am_pm(__tm->tm_hour, __b, __e, __err, __ct);
        -: 1960:    break;
        -: 1961:  case 'r': {
        -: 1962:    const char_type __fm[] = {'%', 'I', ':', '%', 'M', ':', '%', 'S', ' ', '%', 'p'};
        -: 1963:    __b                    = get(__b, __e, __iob, __err, __tm, __fm, __fm + sizeof(__fm) / sizeof(__fm[0]));
        -: 1964:  } break;
        -: 1965:  case 'R': {
        -: 1966:    const char_type __fm[] = {'%', 'H', ':', '%', 'M'};
        -: 1967:    __b                    = get(__b, __e, __iob, __err, __tm, __fm, __fm + sizeof(__fm) / sizeof(__fm[0]));
        -: 1968:  } break;
        -: 1969:  case 'S':
        -: 1970:    __get_second(__tm->tm_sec, __b, __e, __err, __ct);
        -: 1971:    break;
        -: 1972:  case 'T': {
        -: 1973:    const char_type __fm[] = {'%', 'H', ':', '%', 'M', ':', '%', 'S'};
        -: 1974:    __b                    = get(__b, __e, __iob, __err, __tm, __fm, __fm + sizeof(__fm) / sizeof(__fm[0]));
        -: 1975:  } break;
        -: 1976:  case 'w':
        -: 1977:    __get_weekday(__tm->tm_wday, __b, __e, __err, __ct);
        -: 1978:    break;
        -: 1979:  case 'x':
        -: 1980:    return do_get_date(__b, __e, __iob, __err, __tm);
        -: 1981:  case 'X': {
        -: 1982:    const string_type& __fm = this->__X();
        -: 1983:    __b                     = get(__b, __e, __iob, __err, __tm, __fm.data(), __fm.data() + __fm.size());
        -: 1984:  } break;
        -: 1985:  case 'y':
        -: 1986:    __get_year(__tm->tm_year, __b, __e, __err, __ct);
        -: 1987:    break;
        -: 1988:  case 'Y':
        -: 1989:    __get_year4(__tm->tm_year, __b, __e, __err, __ct);
        -: 1990:    break;
        -: 1991:  case '%':
        -: 1992:    __get_percent(__b, __e, __err, __ct);
        -: 1993:    break;
        -: 1994:  default:
        -: 1995:    __err |= ios_base::failbit;
        -: 1996:  }
        -: 1997:  return __b;
        -: 1998:}
        -: 1999:
        -: 2000:extern template class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS time_get<char>;
        -: 2001:#  ifndef _LIBCPP_HAS_NO_WIDE_CHARACTERS
        -: 2002:extern template class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS time_get<wchar_t>;
        -: 2003:#  endif
        -: 2004:
        -: 2005:class _LIBCPP_EXPORTED_FROM_ABI __time_get {
        -: 2006:protected:
        -: 2007:  locale_t __loc_;
        -: 2008:
        -: 2009:  __time_get(const char* __nm);
        -: 2010:  __time_get(const string& __nm);
        -: 2011:  ~__time_get();
        -: 2012:};
        -: 2013:
        -: 2014:template <class _CharT>
        -: 2015:class _LIBCPP_TEMPLATE_VIS __time_get_storage : public __time_get {
        -: 2016:protected:
        -: 2017:  typedef basic_string<_CharT> string_type;
        -: 2018:
        -: 2019:  string_type __weeks_[14];
        -: 2020:  string_type __months_[24];
        -: 2021:  string_type __am_pm_[2];
        -: 2022:  string_type __c_;
        -: 2023:  string_type __r_;
        -: 2024:  string_type __x_;
        -: 2025:  string_type __X_;
        -: 2026:
        -: 2027:  explicit __time_get_storage(const char* __nm);
        -: 2028:  explicit __time_get_storage(const string& __nm);
        -: 2029:
        -: 2030:  _LIBCPP_HIDE_FROM_ABI ~__time_get_storage() {}
        -: 2031:
        -: 2032:  time_base::dateorder __do_date_order() const;
        -: 2033:
        -: 2034:private:
        -: 2035:  void init(const ctype<_CharT>&);
        -: 2036:  string_type __analyze(char __fmt, const ctype<_CharT>&);
        -: 2037:};
        -: 2038:
        -: 2039:#  define _LIBCPP_TIME_GET_STORAGE_EXPLICIT_INSTANTIATION(_CharT)                                                      \
        -: 2040:    template <>                                                                                                        \
        -: 2041:    _LIBCPP_EXPORTED_FROM_ABI time_base::dateorder __time_get_storage<_CharT>::__do_date_order() const;                \
        -: 2042:    template <>                                                                                                        \
        -: 2043:    _LIBCPP_EXPORTED_FROM_ABI __time_get_storage<_CharT>::__time_get_storage(const char*);                             \
        -: 2044:    template <>                                                                                                        \
        -: 2045:    _LIBCPP_EXPORTED_FROM_ABI __time_get_storage<_CharT>::__time_get_storage(const string&);                           \
        -: 2046:    template <>                                                                                                        \
        -: 2047:    _LIBCPP_EXPORTED_FROM_ABI void __time_get_storage<_CharT>::init(const ctype<_CharT>&);                             \
        -: 2048:    template <>                                                                                                        \
        -: 2049:    _LIBCPP_EXPORTED_FROM_ABI __time_get_storage<_CharT>::string_type __time_get_storage<_CharT>::__analyze(           \
        -: 2050:        char, const ctype<_CharT>&);                                                                                   \
        -: 2051:    extern template _LIBCPP_EXPORTED_FROM_ABI time_base::dateorder __time_get_storage<_CharT>::__do_date_order()       \
        -: 2052:        const;                                                                                                         \
        -: 2053:    extern template _LIBCPP_EXPORTED_FROM_ABI __time_get_storage<_CharT>::__time_get_storage(const char*);             \
        -: 2054:    extern template _LIBCPP_EXPORTED_FROM_ABI __time_get_storage<_CharT>::__time_get_storage(const string&);           \
        -: 2055:    extern template _LIBCPP_EXPORTED_FROM_ABI void __time_get_storage<_CharT>::init(const ctype<_CharT>&);             \
        -: 2056:    extern template _LIBCPP_EXPORTED_FROM_ABI __time_get_storage<_CharT>::string_type                                  \
        -: 2057:    __time_get_storage<_CharT>::__analyze(char, const ctype<_CharT>&);                                                 \
        -: 2058:    /**/
        -: 2059:
        -: 2060:_LIBCPP_TIME_GET_STORAGE_EXPLICIT_INSTANTIATION(char)
        -: 2061:#  ifndef _LIBCPP_HAS_NO_WIDE_CHARACTERS
        -: 2062:_LIBCPP_TIME_GET_STORAGE_EXPLICIT_INSTANTIATION(wchar_t)
        -: 2063:#  endif
        -: 2064:#  undef _LIBCPP_TIME_GET_STORAGE_EXPLICIT_INSTANTIATION
        -: 2065:
        -: 2066:template <class _CharT, class _InputIterator = istreambuf_iterator<_CharT> >
        -: 2067:class _LIBCPP_TEMPLATE_VIS time_get_byname
        -: 2068:    : public time_get<_CharT, _InputIterator>,
        -: 2069:      private __time_get_storage<_CharT> {
        -: 2070:public:
        -: 2071:  typedef time_base::dateorder dateorder;
        -: 2072:  typedef _InputIterator iter_type;
        -: 2073:  typedef _CharT char_type;
        -: 2074:  typedef basic_string<char_type> string_type;
        -: 2075:
        -: 2076:  _LIBCPP_HIDE_FROM_ABI explicit time_get_byname(const char* __nm, size_t __refs = 0)
        -: 2077:      : time_get<_CharT, _InputIterator>(__refs), __time_get_storage<_CharT>(__nm) {}
        -: 2078:  _LIBCPP_HIDE_FROM_ABI explicit time_get_byname(const string& __nm, size_t __refs = 0)
        -: 2079:      : time_get<_CharT, _InputIterator>(__refs), __time_get_storage<_CharT>(__nm) {}
        -: 2080:
        -: 2081:protected:
        -: 2082:  _LIBCPP_HIDE_FROM_ABI_VIRTUAL ~time_get_byname() override {}
        -: 2083:
        -: 2084:  _LIBCPP_HIDE_FROM_ABI_VIRTUAL dateorder do_date_order() const override { return this->__do_date_order(); }
        -: 2085:
        -: 2086:private:
        -: 2087:  _LIBCPP_HIDE_FROM_ABI_VIRTUAL const string_type* __weeks() const override { return this->__weeks_; }
        -: 2088:  _LIBCPP_HIDE_FROM_ABI_VIRTUAL const string_type* __months() const override { return this->__months_; }
        -: 2089:  _LIBCPP_HIDE_FROM_ABI_VIRTUAL const string_type* __am_pm() const override { return this->__am_pm_; }
        -: 2090:  _LIBCPP_HIDE_FROM_ABI_VIRTUAL const string_type& __c() const override { return this->__c_; }
        -: 2091:  _LIBCPP_HIDE_FROM_ABI_VIRTUAL const string_type& __r() const override { return this->__r_; }
        -: 2092:  _LIBCPP_HIDE_FROM_ABI_VIRTUAL const string_type& __x() const override { return this->__x_; }
        -: 2093:  _LIBCPP_HIDE_FROM_ABI_VIRTUAL const string_type& __X() const override { return this->__X_; }
        -: 2094:};
        -: 2095:
        -: 2096:extern template class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS time_get_byname<char>;
        -: 2097:#  ifndef _LIBCPP_HAS_NO_WIDE_CHARACTERS
        -: 2098:extern template class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS time_get_byname<wchar_t>;
        -: 2099:#  endif
        -: 2100:
        -: 2101:class _LIBCPP_EXPORTED_FROM_ABI __time_put {
        -: 2102:  locale_t __loc_;
        -: 2103:
        -: 2104:protected:
        -: 2105:  _LIBCPP_HIDE_FROM_ABI __time_put() : __loc_(_LIBCPP_GET_C_LOCALE) {}
        -: 2106:  __time_put(const char* __nm);
        -: 2107:  __time_put(const string& __nm);
        -: 2108:  ~__time_put();
        -: 2109:  void __do_put(char* __nb, char*& __ne, const tm* __tm, char __fmt, char __mod) const;
        -: 2110:#  ifndef _LIBCPP_HAS_NO_WIDE_CHARACTERS
        -: 2111:  void __do_put(wchar_t* __wb, wchar_t*& __we, const tm* __tm, char __fmt, char __mod) const;
        -: 2112:#  endif
        -: 2113:};
        -: 2114:
        -: 2115:template <class _CharT, class _OutputIterator = ostreambuf_iterator<_CharT> >
        -: 2116:class _LIBCPP_TEMPLATE_VIS time_put : public locale::facet, private __time_put {
        -: 2117:public:
        -: 2118:  typedef _CharT char_type;
        -: 2119:  typedef _OutputIterator iter_type;
        -: 2120:
        -: 2121:  _LIBCPP_HIDE_FROM_ABI explicit time_put(size_t __refs = 0) : locale::facet(__refs) {}
        -: 2122:
        -: 2123:  iter_type
        -: 2124:  put(iter_type __s, ios_base& __iob, char_type __fl, const tm* __tm, const char_type* __pb, const char_type* __pe)
        -: 2125:      const;
        -: 2126:
        -: 2127:  _LIBCPP_HIDE_FROM_ABI iter_type
        -: 2128:  put(iter_type __s, ios_base& __iob, char_type __fl, const tm* __tm, char __fmt, char __mod = 0) const {
        -: 2129:    return do_put(__s, __iob, __fl, __tm, __fmt, __mod);
        -: 2130:  }
        -: 2131:
        -: 2132:  static locale::id id;
        -: 2133:
        -: 2134:protected:
        -: 2135:  _LIBCPP_HIDE_FROM_ABI_VIRTUAL ~time_put() override {}
        -: 2136:  virtual iter_type do_put(iter_type __s, ios_base&, char_type, const tm* __tm, char __fmt, char __mod) const;
        -: 2137:
        -: 2138:  _LIBCPP_HIDE_FROM_ABI explicit time_put(const char* __nm, size_t __refs) : locale::facet(__refs), __time_put(__nm) {}
        -: 2139:  _LIBCPP_HIDE_FROM_ABI explicit time_put(const string& __nm, size_t __refs)
        -: 2140:      : locale::facet(__refs), __time_put(__nm) {}
        -: 2141:};
        -: 2142:
        -: 2143:template <class _CharT, class _OutputIterator>
        -: 2144:locale::id time_put<_CharT, _OutputIterator>::id;
        -: 2145:
        -: 2146:template <class _CharT, class _OutputIterator>
        -: 2147:_OutputIterator time_put<_CharT, _OutputIterator>::put(
        -: 2148:    iter_type __s, ios_base& __iob, char_type __fl, const tm* __tm, const char_type* __pb, const char_type* __pe)
        -: 2149:    const {
        -: 2150:  const ctype<char_type>& __ct = std::use_facet<ctype<char_type> >(__iob.getloc());
        -: 2151:  for (; __pb != __pe; ++__pb) {
        -: 2152:    if (__ct.narrow(*__pb, 0) == '%') {
        -: 2153:      if (++__pb == __pe) {
        -: 2154:        *__s++ = __pb[-1];
        -: 2155:        break;
        -: 2156:      }
        -: 2157:      char __mod = 0;
        -: 2158:      char __fmt = __ct.narrow(*__pb, 0);
        -: 2159:      if (__fmt == 'E' || __fmt == 'O') {
        -: 2160:        if (++__pb == __pe) {
        -: 2161:          *__s++ = __pb[-2];
        -: 2162:          *__s++ = __pb[-1];
        -: 2163:          break;
        -: 2164:        }
        -: 2165:        __mod = __fmt;
        -: 2166:        __fmt = __ct.narrow(*__pb, 0);
        -: 2167:      }
        -: 2168:      __s = do_put(__s, __iob, __fl, __tm, __fmt, __mod);
        -: 2169:    } else
        -: 2170:      *__s++ = *__pb;
        -: 2171:  }
        -: 2172:  return __s;
        -: 2173:}
        -: 2174:
        -: 2175:template <class _CharT, class _OutputIterator>
        -: 2176:_OutputIterator time_put<_CharT, _OutputIterator>::do_put(
        -: 2177:    iter_type __s, ios_base&, char_type, const tm* __tm, char __fmt, char __mod) const {
        -: 2178:  char_type __nar[100];
        -: 2179:  char_type* __nb = __nar;
        -: 2180:  char_type* __ne = __nb + 100;
        -: 2181:  __do_put(__nb, __ne, __tm, __fmt, __mod);
        -: 2182:  return std::copy(__nb, __ne, __s);
        -: 2183:}
        -: 2184:
        -: 2185:extern template class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS time_put<char>;
        -: 2186:#  ifndef _LIBCPP_HAS_NO_WIDE_CHARACTERS
        -: 2187:extern template class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS time_put<wchar_t>;
        -: 2188:#  endif
        -: 2189:
        -: 2190:template <class _CharT, class _OutputIterator = ostreambuf_iterator<_CharT> >
        -: 2191:class _LIBCPP_TEMPLATE_VIS time_put_byname : public time_put<_CharT, _OutputIterator> {
        -: 2192:public:
        -: 2193:  _LIBCPP_HIDE_FROM_ABI explicit time_put_byname(const char* __nm, size_t __refs = 0)
        -: 2194:      : time_put<_CharT, _OutputIterator>(__nm, __refs) {}
        -: 2195:
        -: 2196:  _LIBCPP_HIDE_FROM_ABI explicit time_put_byname(const string& __nm, size_t __refs = 0)
        -: 2197:      : time_put<_CharT, _OutputIterator>(__nm, __refs) {}
        -: 2198:
        -: 2199:protected:
        -: 2200:  _LIBCPP_HIDE_FROM_ABI_VIRTUAL ~time_put_byname() override {}
        -: 2201:};
        -: 2202:
        -: 2203:extern template class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS time_put_byname<char>;
        -: 2204:#  ifndef _LIBCPP_HAS_NO_WIDE_CHARACTERS
        -: 2205:extern template class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS time_put_byname<wchar_t>;
        -: 2206:#  endif
        -: 2207:
        -: 2208:// money_base
        -: 2209:
        -: 2210:class _LIBCPP_EXPORTED_FROM_ABI money_base {
        -: 2211:public:
        -: 2212:  enum part { none, space, symbol, sign, value };
        -: 2213:  struct pattern {
        -: 2214:    char field[4];
        -: 2215:  };
        -: 2216:
        -: 2217:  _LIBCPP_HIDE_FROM_ABI money_base() {}
        -: 2218:};
        -: 2219:
        -: 2220:// moneypunct
        -: 2221:
        -: 2222:template <class _CharT, bool _International = false>
        -: 2223:class _LIBCPP_TEMPLATE_VIS moneypunct : public locale::facet, public money_base {
        -: 2224:public:
        -: 2225:  typedef _CharT char_type;
        -: 2226:  typedef basic_string<char_type> string_type;
        -: 2227:
        -: 2228:  _LIBCPP_HIDE_FROM_ABI explicit moneypunct(size_t __refs = 0) : locale::facet(__refs) {}
        -: 2229:
        -: 2230:  _LIBCPP_HIDE_FROM_ABI char_type decimal_point() const { return do_decimal_point(); }
        -: 2231:  _LIBCPP_HIDE_FROM_ABI char_type thousands_sep() const { return do_thousands_sep(); }
        -: 2232:  _LIBCPP_HIDE_FROM_ABI string grouping() const { return do_grouping(); }
        -: 2233:  _LIBCPP_HIDE_FROM_ABI string_type curr_symbol() const { return do_curr_symbol(); }
        -: 2234:  _LIBCPP_HIDE_FROM_ABI string_type positive_sign() const { return do_positive_sign(); }
        -: 2235:  _LIBCPP_HIDE_FROM_ABI string_type negative_sign() const { return do_negative_sign(); }
        -: 2236:  _LIBCPP_HIDE_FROM_ABI int frac_digits() const { return do_frac_digits(); }
        -: 2237:  _LIBCPP_HIDE_FROM_ABI pattern pos_format() const { return do_pos_format(); }
        -: 2238:  _LIBCPP_HIDE_FROM_ABI pattern neg_format() const { return do_neg_format(); }
        -: 2239:
        -: 2240:  static locale::id id;
        -: 2241:  static const bool intl = _International;
        -: 2242:
        -: 2243:protected:
        -: 2244:  _LIBCPP_HIDE_FROM_ABI_VIRTUAL ~moneypunct() override {}
        -: 2245:
        -: 2246:  virtual char_type do_decimal_point() const { return numeric_limits<char_type>::max(); }
        -: 2247:  virtual char_type do_thousands_sep() const { return numeric_limits<char_type>::max(); }
        -: 2248:  virtual string do_grouping() const { return string(); }
        -: 2249:  virtual string_type do_curr_symbol() const { return string_type(); }
        -: 2250:  virtual string_type do_positive_sign() const { return string_type(); }
        -: 2251:  virtual string_type do_negative_sign() const { return string_type(1, '-'); }
        -: 2252:  virtual int do_frac_digits() const { return 0; }
        -: 2253:  virtual pattern do_pos_format() const {
        -: 2254:    pattern __p = {{symbol, sign, none, value}};
        -: 2255:    return __p;
        -: 2256:  }
        -: 2257:  virtual pattern do_neg_format() const {
        -: 2258:    pattern __p = {{symbol, sign, none, value}};
        -: 2259:    return __p;
        -: 2260:  }
        -: 2261:};
        -: 2262:
        -: 2263:template <class _CharT, bool _International>
        -: 2264:locale::id moneypunct<_CharT, _International>::id;
        -: 2265:
        -: 2266:template <class _CharT, bool _International>
        -: 2267:const bool moneypunct<_CharT, _International>::intl;
        -: 2268:
        -: 2269:extern template class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS moneypunct<char, false>;
        -: 2270:extern template class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS moneypunct<char, true>;
        -: 2271:#  ifndef _LIBCPP_HAS_NO_WIDE_CHARACTERS
        -: 2272:extern template class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS moneypunct<wchar_t, false>;
        -: 2273:extern template class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS moneypunct<wchar_t, true>;
        -: 2274:#  endif
        -: 2275:
        -: 2276:// moneypunct_byname
        -: 2277:
        -: 2278:template <class _CharT, bool _International = false>
        -: 2279:class _LIBCPP_TEMPLATE_VIS moneypunct_byname : public moneypunct<_CharT, _International> {
        -: 2280:public:
        -: 2281:  typedef money_base::pattern pattern;
        -: 2282:  typedef _CharT char_type;
        -: 2283:  typedef basic_string<char_type> string_type;
        -: 2284:
        -: 2285:  _LIBCPP_HIDE_FROM_ABI explicit moneypunct_byname(const char* __nm, size_t __refs = 0)
        -: 2286:      : moneypunct<_CharT, _International>(__refs) {
        -: 2287:    init(__nm);
        -: 2288:  }
        -: 2289:
        -: 2290:  _LIBCPP_HIDE_FROM_ABI explicit moneypunct_byname(const string& __nm, size_t __refs = 0)
        -: 2291:      : moneypunct<_CharT, _International>(__refs) {
        -: 2292:    init(__nm.c_str());
        -: 2293:  }
        -: 2294:
        -: 2295:protected:
        -: 2296:  _LIBCPP_HIDE_FROM_ABI_VIRTUAL ~moneypunct_byname() override {}
        -: 2297:
        -: 2298:  char_type do_decimal_point() const override { return __decimal_point_; }
        -: 2299:  char_type do_thousands_sep() const override { return __thousands_sep_; }
        -: 2300:  string do_grouping() const override { return __grouping_; }
        -: 2301:  string_type do_curr_symbol() const override { return __curr_symbol_; }
        -: 2302:  string_type do_positive_sign() const override { return __positive_sign_; }
        -: 2303:  string_type do_negative_sign() const override { return __negative_sign_; }
        -: 2304:  int do_frac_digits() const override { return __frac_digits_; }
        -: 2305:  pattern do_pos_format() const override { return __pos_format_; }
        -: 2306:  pattern do_neg_format() const override { return __neg_format_; }
        -: 2307:
        -: 2308:private:
        -: 2309:  char_type __decimal_point_;
        -: 2310:  char_type __thousands_sep_;
        -: 2311:  string __grouping_;
        -: 2312:  string_type __curr_symbol_;
        -: 2313:  string_type __positive_sign_;
        -: 2314:  string_type __negative_sign_;
        -: 2315:  int __frac_digits_;
        -: 2316:  pattern __pos_format_;
        -: 2317:  pattern __neg_format_;
        -: 2318:
        -: 2319:  void init(const char*);
        -: 2320:};
        -: 2321:
        -: 2322:template <>
        -: 2323:_LIBCPP_EXPORTED_FROM_ABI void moneypunct_byname<char, false>::init(const char*);
        -: 2324:template <>
        -: 2325:_LIBCPP_EXPORTED_FROM_ABI void moneypunct_byname<char, true>::init(const char*);
        -: 2326:extern template class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS moneypunct_byname<char, false>;
        -: 2327:extern template class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS moneypunct_byname<char, true>;
        -: 2328:
        -: 2329:#  ifndef _LIBCPP_HAS_NO_WIDE_CHARACTERS
        -: 2330:template <>
        -: 2331:_LIBCPP_EXPORTED_FROM_ABI void moneypunct_byname<wchar_t, false>::init(const char*);
        -: 2332:template <>
        -: 2333:_LIBCPP_EXPORTED_FROM_ABI void moneypunct_byname<wchar_t, true>::init(const char*);
        -: 2334:extern template class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS moneypunct_byname<wchar_t, false>;
        -: 2335:extern template class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS moneypunct_byname<wchar_t, true>;
        -: 2336:#  endif
        -: 2337:
        -: 2338:// money_get
        -: 2339:
        -: 2340:template <class _CharT>
        -: 2341:class __money_get {
        -: 2342:protected:
        -: 2343:  typedef _CharT char_type;
        -: 2344:  typedef basic_string<char_type> string_type;
        -: 2345:
        -: 2346:  _LIBCPP_HIDE_FROM_ABI __money_get() {}
        -: 2347:
        -: 2348:  static void __gather_info(
        -: 2349:      bool __intl,
        -: 2350:      const locale& __loc,
        -: 2351:      money_base::pattern& __pat,
        -: 2352:      char_type& __dp,
        -: 2353:      char_type& __ts,
        -: 2354:      string& __grp,
        -: 2355:      string_type& __sym,
        -: 2356:      string_type& __psn,
        -: 2357:      string_type& __nsn,
        -: 2358:      int& __fd);
        -: 2359:};
        -: 2360:
        -: 2361:template <class _CharT>
        -: 2362:void __money_get<_CharT>::__gather_info(
        -: 2363:    bool __intl,
        -: 2364:    const locale& __loc,
        -: 2365:    money_base::pattern& __pat,
        -: 2366:    char_type& __dp,
        -: 2367:    char_type& __ts,
        -: 2368:    string& __grp,
        -: 2369:    string_type& __sym,
        -: 2370:    string_type& __psn,
        -: 2371:    string_type& __nsn,
        -: 2372:    int& __fd) {
        -: 2373:  if (__intl) {
        -: 2374:    const moneypunct<char_type, true>& __mp = std::use_facet<moneypunct<char_type, true> >(__loc);
        -: 2375:    __pat                                   = __mp.neg_format();
        -: 2376:    __nsn                                   = __mp.negative_sign();
        -: 2377:    __psn                                   = __mp.positive_sign();
        -: 2378:    __dp                                    = __mp.decimal_point();
        -: 2379:    __ts                                    = __mp.thousands_sep();
        -: 2380:    __grp                                   = __mp.grouping();
        -: 2381:    __sym                                   = __mp.curr_symbol();
        -: 2382:    __fd                                    = __mp.frac_digits();
        -: 2383:  } else {
        -: 2384:    const moneypunct<char_type, false>& __mp = std::use_facet<moneypunct<char_type, false> >(__loc);
        -: 2385:    __pat                                    = __mp.neg_format();
        -: 2386:    __nsn                                    = __mp.negative_sign();
        -: 2387:    __psn                                    = __mp.positive_sign();
        -: 2388:    __dp                                     = __mp.decimal_point();
        -: 2389:    __ts                                     = __mp.thousands_sep();
        -: 2390:    __grp                                    = __mp.grouping();
        -: 2391:    __sym                                    = __mp.curr_symbol();
        -: 2392:    __fd                                     = __mp.frac_digits();
        -: 2393:  }
        -: 2394:}
        -: 2395:
        -: 2396:extern template class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS __money_get<char>;
        -: 2397:#  ifndef _LIBCPP_HAS_NO_WIDE_CHARACTERS
        -: 2398:extern template class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS __money_get<wchar_t>;
        -: 2399:#  endif
        -: 2400:
        -: 2401:template <class _CharT, class _InputIterator = istreambuf_iterator<_CharT> >
        -: 2402:class _LIBCPP_TEMPLATE_VIS money_get : public locale::facet, private __money_get<_CharT> {
        -: 2403:public:
        -: 2404:  typedef _CharT char_type;
        -: 2405:  typedef _InputIterator iter_type;
        -: 2406:  typedef basic_string<char_type> string_type;
        -: 2407:
        -: 2408:  _LIBCPP_HIDE_FROM_ABI explicit money_get(size_t __refs = 0) : locale::facet(__refs) {}
        -: 2409:
        -: 2410:  _LIBCPP_HIDE_FROM_ABI iter_type
        -: 2411:  get(iter_type __b, iter_type __e, bool __intl, ios_base& __iob, ios_base::iostate& __err, long double& __v) const {
        -: 2412:    return do_get(__b, __e, __intl, __iob, __err, __v);
        -: 2413:  }
        -: 2414:
        -: 2415:  _LIBCPP_HIDE_FROM_ABI iter_type
        -: 2416:  get(iter_type __b, iter_type __e, bool __intl, ios_base& __iob, ios_base::iostate& __err, string_type& __v) const {
        -: 2417:    return do_get(__b, __e, __intl, __iob, __err, __v);
        -: 2418:  }
        -: 2419:
        -: 2420:  static locale::id id;
        -: 2421:
        -: 2422:protected:
        -: 2423:  _LIBCPP_HIDE_FROM_ABI_VIRTUAL ~money_get() override {}
        -: 2424:
        -: 2425:  virtual iter_type
        -: 2426:  do_get(iter_type __b, iter_type __e, bool __intl, ios_base& __iob, ios_base::iostate& __err, long double& __v) const;
        -: 2427:  virtual iter_type
        -: 2428:  do_get(iter_type __b, iter_type __e, bool __intl, ios_base& __iob, ios_base::iostate& __err, string_type& __v) const;
        -: 2429:
        -: 2430:private:
        -: 2431:  static bool __do_get(
        -: 2432:      iter_type& __b,
        -: 2433:      iter_type __e,
        -: 2434:      bool __intl,
        -: 2435:      const locale& __loc,
        -: 2436:      ios_base::fmtflags __flags,
        -: 2437:      ios_base::iostate& __err,
        -: 2438:      bool& __neg,
        -: 2439:      const ctype<char_type>& __ct,
        -: 2440:      unique_ptr<char_type, void (*)(void*)>& __wb,
        -: 2441:      char_type*& __wn,
        -: 2442:      char_type* __we);
        -: 2443:};
        -: 2444:
        -: 2445:template <class _CharT, class _InputIterator>
        -: 2446:locale::id money_get<_CharT, _InputIterator>::id;
        -: 2447:
        -: 2448:_LIBCPP_EXPORTED_FROM_ABI void __do_nothing(void*);
        -: 2449:
        -: 2450:template <class _Tp>
        -: 2451:_LIBCPP_HIDE_FROM_ABI void __double_or_nothing(unique_ptr<_Tp, void (*)(void*)>& __b, _Tp*& __n, _Tp*& __e) {
        -: 2452:  bool __owns      = __b.get_deleter() != __do_nothing;
        -: 2453:  size_t __cur_cap = static_cast<size_t>(__e - __b.get()) * sizeof(_Tp);
        -: 2454:  size_t __new_cap = __cur_cap < numeric_limits<size_t>::max() / 2 ? 2 * __cur_cap : numeric_limits<size_t>::max();
        -: 2455:  if (__new_cap == 0)
        -: 2456:    __new_cap = sizeof(_Tp);
        -: 2457:  size_t __n_off = static_cast<size_t>(__n - __b.get());
        -: 2458:  _Tp* __t       = (_Tp*)std::realloc(__owns ? __b.get() : 0, __new_cap);
        -: 2459:  if (__t == 0)
        -: 2460:    __throw_bad_alloc();
        -: 2461:  if (__owns)
        -: 2462:    __b.release();
        -: 2463:  __b = unique_ptr<_Tp, void (*)(void*)>(__t, free);
        -: 2464:  __new_cap /= sizeof(_Tp);
        -: 2465:  __n = __b.get() + __n_off;
        -: 2466:  __e = __b.get() + __new_cap;
        -: 2467:}
        -: 2468:
        -: 2469:// true == success
        -: 2470:template <class _CharT, class _InputIterator>
        -: 2471:bool money_get<_CharT, _InputIterator>::__do_get(
        -: 2472:    iter_type& __b,
        -: 2473:    iter_type __e,
        -: 2474:    bool __intl,
        -: 2475:    const locale& __loc,
        -: 2476:    ios_base::fmtflags __flags,
        -: 2477:    ios_base::iostate& __err,
        -: 2478:    bool& __neg,
        -: 2479:    const ctype<char_type>& __ct,
        -: 2480:    unique_ptr<char_type, void (*)(void*)>& __wb,
        -: 2481:    char_type*& __wn,
        -: 2482:    char_type* __we) {
        -: 2483:  if (__b == __e) {
        -: 2484:    __err |= ios_base::failbit;
        -: 2485:    return false;
        -: 2486:  }
        -: 2487:  const unsigned __bz = 100;
        -: 2488:  unsigned __gbuf[__bz];
        -: 2489:  unique_ptr<unsigned, void (*)(void*)> __gb(__gbuf, __do_nothing);
        -: 2490:  unsigned* __gn = __gb.get();
        -: 2491:  unsigned* __ge = __gn + __bz;
        -: 2492:  money_base::pattern __pat;
        -: 2493:  char_type __dp;
        -: 2494:  char_type __ts;
        -: 2495:  string __grp;
        -: 2496:  string_type __sym;
        -: 2497:  string_type __psn;
        -: 2498:  string_type __nsn;
        -: 2499:  // Capture the spaces read into money_base::{space,none} so they
        -: 2500:  // can be compared to initial spaces in __sym.
        -: 2501:  string_type __spaces;
        -: 2502:  int __fd;
        -: 2503:  __money_get<_CharT>::__gather_info(__intl, __loc, __pat, __dp, __ts, __grp, __sym, __psn, __nsn, __fd);
        -: 2504:  const string_type* __trailing_sign = 0;
        -: 2505:  __wn                               = __wb.get();
        -: 2506:  for (unsigned __p = 0; __p < 4 && __b != __e; ++__p) {
        -: 2507:    switch (__pat.field[__p]) {
        -: 2508:    case money_base::space:
        -: 2509:      if (__p != 3) {
        -: 2510:        if (__ct.is(ctype_base::space, *__b))
        -: 2511:          __spaces.push_back(*__b++);
        -: 2512:        else {
        -: 2513:          __err |= ios_base::failbit;
        -: 2514:          return false;
        -: 2515:        }
        -: 2516:      }
        -: 2517:      _LIBCPP_FALLTHROUGH();
        -: 2518:    case money_base::none:
        -: 2519:      if (__p != 3) {
        -: 2520:        while (__b != __e && __ct.is(ctype_base::space, *__b))
        -: 2521:          __spaces.push_back(*__b++);
        -: 2522:      }
        -: 2523:      break;
        -: 2524:    case money_base::sign:
        -: 2525:      if (__psn.size() > 0 && *__b == __psn[0]) {
        -: 2526:        ++__b;
        -: 2527:        __neg = false;
        -: 2528:        if (__psn.size() > 1)
        -: 2529:          __trailing_sign = &__psn;
        -: 2530:        break;
        -: 2531:      }
        -: 2532:      if (__nsn.size() > 0 && *__b == __nsn[0]) {
        -: 2533:        ++__b;
        -: 2534:        __neg = true;
        -: 2535:        if (__nsn.size() > 1)
        -: 2536:          __trailing_sign = &__nsn;
        -: 2537:        break;
        -: 2538:      }
        -: 2539:      if (__psn.size() > 0 && __nsn.size() > 0) { // sign is required
        -: 2540:        __err |= ios_base::failbit;
        -: 2541:        return false;
        -: 2542:      }
        -: 2543:      if (__psn.size() == 0 && __nsn.size() == 0)
        -: 2544:        // locale has no way of specifying a sign. Use the initial value of __neg as a default
        -: 2545:        break;
        -: 2546:      __neg = (__nsn.size() == 0);
        -: 2547:      break;
        -: 2548:    case money_base::symbol: {
        -: 2549:      bool __more_needed =
        -: 2550:          __trailing_sign || (__p < 2) || (__p == 2 && __pat.field[3] != static_cast<char>(money_base::none));
        -: 2551:      bool __sb = (__flags & ios_base::showbase) != 0;
        -: 2552:      if (__sb || __more_needed) {
        -: 2553:        typename string_type::const_iterator __sym_space_end = __sym.begin();
        -: 2554:        if (__p > 0 && (__pat.field[__p - 1] == money_base::none || __pat.field[__p - 1] == money_base::space)) {
        -: 2555:          // Match spaces we've already read against spaces at
        -: 2556:          // the beginning of __sym.
        -: 2557:          while (__sym_space_end != __sym.end() && __ct.is(ctype_base::space, *__sym_space_end))
        -: 2558:            ++__sym_space_end;
        -: 2559:          const size_t __num_spaces = __sym_space_end - __sym.begin();
        -: 2560:          if (__num_spaces > __spaces.size() ||
        -: 2561:              !std::equal(__spaces.end() - __num_spaces, __spaces.end(), __sym.begin())) {
        -: 2562:            // No match. Put __sym_space_end back at the
        -: 2563:            // beginning of __sym, which will prevent a
        -: 2564:            // match in the next loop.
        -: 2565:            __sym_space_end = __sym.begin();
        -: 2566:          }
        -: 2567:        }
        -: 2568:        typename string_type::const_iterator __sym_curr_char = __sym_space_end;
        -: 2569:        while (__sym_curr_char != __sym.end() && __b != __e && *__b == *__sym_curr_char) {
        -: 2570:          ++__b;
        -: 2571:          ++__sym_curr_char;
        -: 2572:        }
        -: 2573:        if (__sb && __sym_curr_char != __sym.end()) {
        -: 2574:          __err |= ios_base::failbit;
        -: 2575:          return false;
        -: 2576:        }
        -: 2577:      }
        -: 2578:    } break;
        -: 2579:    case money_base::value: {
        -: 2580:      unsigned __ng = 0;
        -: 2581:      for (; __b != __e; ++__b) {
        -: 2582:        char_type __c = *__b;
        -: 2583:        if (__ct.is(ctype_base::digit, __c)) {
        -: 2584:          if (__wn == __we)
        -: 2585:            std::__double_or_nothing(__wb, __wn, __we);
        -: 2586:          *__wn++ = __c;
        -: 2587:          ++__ng;
        -: 2588:        } else if (__grp.size() > 0 && __ng > 0 && __c == __ts) {
        -: 2589:          if (__gn == __ge)
        -: 2590:            std::__double_or_nothing(__gb, __gn, __ge);
        -: 2591:          *__gn++ = __ng;
        -: 2592:          __ng    = 0;
        -: 2593:        } else
        -: 2594:          break;
        -: 2595:      }
        -: 2596:      if (__gb.get() != __gn && __ng > 0) {
        -: 2597:        if (__gn == __ge)
        -: 2598:          std::__double_or_nothing(__gb, __gn, __ge);
        -: 2599:        *__gn++ = __ng;
        -: 2600:      }
        -: 2601:      if (__fd > 0) {
        -: 2602:        if (__b == __e || *__b != __dp) {
        -: 2603:          __err |= ios_base::failbit;
        -: 2604:          return false;
        -: 2605:        }
        -: 2606:        for (++__b; __fd > 0; --__fd, ++__b) {
        -: 2607:          if (__b == __e || !__ct.is(ctype_base::digit, *__b)) {
        -: 2608:            __err |= ios_base::failbit;
        -: 2609:            return false;
        -: 2610:          }
        -: 2611:          if (__wn == __we)
        -: 2612:            std::__double_or_nothing(__wb, __wn, __we);
        -: 2613:          *__wn++ = *__b;
        -: 2614:        }
        -: 2615:      }
        -: 2616:      if (__wn == __wb.get()) {
        -: 2617:        __err |= ios_base::failbit;
        -: 2618:        return false;
        -: 2619:      }
        -: 2620:    } break;
        -: 2621:    }
        -: 2622:  }
        -: 2623:  if (__trailing_sign) {
        -: 2624:    for (unsigned __i = 1; __i < __trailing_sign->size(); ++__i, ++__b) {
        -: 2625:      if (__b == __e || *__b != (*__trailing_sign)[__i]) {
        -: 2626:        __err |= ios_base::failbit;
        -: 2627:        return false;
        -: 2628:      }
        -: 2629:    }
        -: 2630:  }
        -: 2631:  if (__gb.get() != __gn) {
        -: 2632:    ios_base::iostate __et = ios_base::goodbit;
        -: 2633:    __check_grouping(__grp, __gb.get(), __gn, __et);
        -: 2634:    if (__et) {
        -: 2635:      __err |= ios_base::failbit;
        -: 2636:      return false;
        -: 2637:    }
        -: 2638:  }
        -: 2639:  return true;
        -: 2640:}
        -: 2641:
        -: 2642:template <class _CharT, class _InputIterator>
        -: 2643:_InputIterator money_get<_CharT, _InputIterator>::do_get(
        -: 2644:    iter_type __b, iter_type __e, bool __intl, ios_base& __iob, ios_base::iostate& __err, long double& __v) const {
        -: 2645:  const int __bz = 100;
        -: 2646:  char_type __wbuf[__bz];
        -: 2647:  unique_ptr<char_type, void (*)(void*)> __wb(__wbuf, __do_nothing);
        -: 2648:  char_type* __wn;
        -: 2649:  char_type* __we              = __wbuf + __bz;
        -: 2650:  locale __loc                 = __iob.getloc();
        -: 2651:  const ctype<char_type>& __ct = std::use_facet<ctype<char_type> >(__loc);
        -: 2652:  bool __neg                   = false;
        -: 2653:  if (__do_get(__b, __e, __intl, __loc, __iob.flags(), __err, __neg, __ct, __wb, __wn, __we)) {
        -: 2654:    const char __src[] = "0123456789";
        -: 2655:    char_type __atoms[sizeof(__src) - 1];
        -: 2656:    __ct.widen(__src, __src + (sizeof(__src) - 1), __atoms);
        -: 2657:    char __nbuf[__bz];
        -: 2658:    char* __nc = __nbuf;
        -: 2659:    unique_ptr<char, void (*)(void*)> __h(nullptr, free);
        -: 2660:    if (__wn - __wb.get() > __bz - 2) {
        -: 2661:      __h.reset((char*)malloc(static_cast<size_t>(__wn - __wb.get() + 2)));
        -: 2662:      if (__h.get() == nullptr)
        -: 2663:        __throw_bad_alloc();
        -: 2664:      __nc = __h.get();
        -: 2665:    }
        -: 2666:    if (__neg)
        -: 2667:      *__nc++ = '-';
        -: 2668:    for (const char_type* __w = __wb.get(); __w < __wn; ++__w, ++__nc)
        -: 2669:      *__nc = __src[std::find(__atoms, std::end(__atoms), *__w) - __atoms];
        -: 2670:    *__nc = char();
        -: 2671:    if (sscanf(__nbuf, "%Lf", &__v) != 1)
        -: 2672:      __throw_runtime_error("money_get error");
        -: 2673:  }
        -: 2674:  if (__b == __e)
        -: 2675:    __err |= ios_base::eofbit;
        -: 2676:  return __b;
        -: 2677:}
        -: 2678:
        -: 2679:template <class _CharT, class _InputIterator>
        -: 2680:_InputIterator money_get<_CharT, _InputIterator>::do_get(
        -: 2681:    iter_type __b, iter_type __e, bool __intl, ios_base& __iob, ios_base::iostate& __err, string_type& __v) const {
        -: 2682:  const int __bz = 100;
        -: 2683:  char_type __wbuf[__bz];
        -: 2684:  unique_ptr<char_type, void (*)(void*)> __wb(__wbuf, __do_nothing);
        -: 2685:  char_type* __wn;
        -: 2686:  char_type* __we              = __wbuf + __bz;
        -: 2687:  locale __loc                 = __iob.getloc();
        -: 2688:  const ctype<char_type>& __ct = std::use_facet<ctype<char_type> >(__loc);
        -: 2689:  bool __neg                   = false;
        -: 2690:  if (__do_get(__b, __e, __intl, __loc, __iob.flags(), __err, __neg, __ct, __wb, __wn, __we)) {
        -: 2691:    __v.clear();
        -: 2692:    if (__neg)
        -: 2693:      __v.push_back(__ct.widen('-'));
        -: 2694:    char_type __z = __ct.widen('0');
        -: 2695:    char_type* __w;
        -: 2696:    for (__w = __wb.get(); __w < __wn - 1; ++__w)
        -: 2697:      if (*__w != __z)
        -: 2698:        break;
        -: 2699:    __v.append(__w, __wn);
        -: 2700:  }
        -: 2701:  if (__b == __e)
        -: 2702:    __err |= ios_base::eofbit;
        -: 2703:  return __b;
        -: 2704:}
        -: 2705:
        -: 2706:extern template class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS money_get<char>;
        -: 2707:#  ifndef _LIBCPP_HAS_NO_WIDE_CHARACTERS
        -: 2708:extern template class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS money_get<wchar_t>;
        -: 2709:#  endif
        -: 2710:
        -: 2711:// money_put
        -: 2712:
        -: 2713:template <class _CharT>
        -: 2714:class __money_put {
        -: 2715:protected:
        -: 2716:  typedef _CharT char_type;
        -: 2717:  typedef basic_string<char_type> string_type;
        -: 2718:
        -: 2719:  _LIBCPP_HIDE_FROM_ABI __money_put() {}
        -: 2720:
        -: 2721:  static void __gather_info(
        -: 2722:      bool __intl,
        -: 2723:      bool __neg,
        -: 2724:      const locale& __loc,
        -: 2725:      money_base::pattern& __pat,
        -: 2726:      char_type& __dp,
        -: 2727:      char_type& __ts,
        -: 2728:      string& __grp,
        -: 2729:      string_type& __sym,
        -: 2730:      string_type& __sn,
        -: 2731:      int& __fd);
        -: 2732:  static void __format(
        -: 2733:      char_type* __mb,
        -: 2734:      char_type*& __mi,
        -: 2735:      char_type*& __me,
        -: 2736:      ios_base::fmtflags __flags,
        -: 2737:      const char_type* __db,
        -: 2738:      const char_type* __de,
        -: 2739:      const ctype<char_type>& __ct,
        -: 2740:      bool __neg,
        -: 2741:      const money_base::pattern& __pat,
        -: 2742:      char_type __dp,
        -: 2743:      char_type __ts,
        -: 2744:      const string& __grp,
        -: 2745:      const string_type& __sym,
        -: 2746:      const string_type& __sn,
        -: 2747:      int __fd);
        -: 2748:};
        -: 2749:
        -: 2750:template <class _CharT>
        -: 2751:void __money_put<_CharT>::__gather_info(
        -: 2752:    bool __intl,
        -: 2753:    bool __neg,
        -: 2754:    const locale& __loc,
        -: 2755:    money_base::pattern& __pat,
        -: 2756:    char_type& __dp,
        -: 2757:    char_type& __ts,
        -: 2758:    string& __grp,
        -: 2759:    string_type& __sym,
        -: 2760:    string_type& __sn,
        -: 2761:    int& __fd) {
        -: 2762:  if (__intl) {
        -: 2763:    const moneypunct<char_type, true>& __mp = std::use_facet<moneypunct<char_type, true> >(__loc);
        -: 2764:    if (__neg) {
        -: 2765:      __pat = __mp.neg_format();
        -: 2766:      __sn  = __mp.negative_sign();
        -: 2767:    } else {
        -: 2768:      __pat = __mp.pos_format();
        -: 2769:      __sn  = __mp.positive_sign();
        -: 2770:    }
        -: 2771:    __dp  = __mp.decimal_point();
        -: 2772:    __ts  = __mp.thousands_sep();
        -: 2773:    __grp = __mp.grouping();
        -: 2774:    __sym = __mp.curr_symbol();
        -: 2775:    __fd  = __mp.frac_digits();
        -: 2776:  } else {
        -: 2777:    const moneypunct<char_type, false>& __mp = std::use_facet<moneypunct<char_type, false> >(__loc);
        -: 2778:    if (__neg) {
        -: 2779:      __pat = __mp.neg_format();
        -: 2780:      __sn  = __mp.negative_sign();
        -: 2781:    } else {
        -: 2782:      __pat = __mp.pos_format();
        -: 2783:      __sn  = __mp.positive_sign();
        -: 2784:    }
        -: 2785:    __dp  = __mp.decimal_point();
        -: 2786:    __ts  = __mp.thousands_sep();
        -: 2787:    __grp = __mp.grouping();
        -: 2788:    __sym = __mp.curr_symbol();
        -: 2789:    __fd  = __mp.frac_digits();
        -: 2790:  }
        -: 2791:}
        -: 2792:
        -: 2793:template <class _CharT>
        -: 2794:void __money_put<_CharT>::__format(
        -: 2795:    char_type* __mb,
        -: 2796:    char_type*& __mi,
        -: 2797:    char_type*& __me,
        -: 2798:    ios_base::fmtflags __flags,
        -: 2799:    const char_type* __db,
        -: 2800:    const char_type* __de,
        -: 2801:    const ctype<char_type>& __ct,
        -: 2802:    bool __neg,
        -: 2803:    const money_base::pattern& __pat,
        -: 2804:    char_type __dp,
        -: 2805:    char_type __ts,
        -: 2806:    const string& __grp,
        -: 2807:    const string_type& __sym,
        -: 2808:    const string_type& __sn,
        -: 2809:    int __fd) {
        -: 2810:  __me = __mb;
        -: 2811:  for (char __p : __pat.field) {
        -: 2812:    switch (__p) {
        -: 2813:    case money_base::none:
        -: 2814:      __mi = __me;
        -: 2815:      break;
        -: 2816:    case money_base::space:
        -: 2817:      __mi    = __me;
        -: 2818:      *__me++ = __ct.widen(' ');
        -: 2819:      break;
        -: 2820:    case money_base::sign:
        -: 2821:      if (!__sn.empty())
        -: 2822:        *__me++ = __sn[0];
        -: 2823:      break;
        -: 2824:    case money_base::symbol:
        -: 2825:      if (!__sym.empty() && (__flags & ios_base::showbase))
        -: 2826:        __me = std::copy(__sym.begin(), __sym.end(), __me);
        -: 2827:      break;
        -: 2828:    case money_base::value: {
        -: 2829:      // remember start of value so we can reverse it
        -: 2830:      char_type* __t = __me;
        -: 2831:      // find beginning of digits
        -: 2832:      if (__neg)
        -: 2833:        ++__db;
        -: 2834:      // find end of digits
        -: 2835:      const char_type* __d;
        -: 2836:      for (__d = __db; __d < __de; ++__d)
        -: 2837:        if (!__ct.is(ctype_base::digit, *__d))
        -: 2838:          break;
        -: 2839:      // print fractional part
        -: 2840:      if (__fd > 0) {
        -: 2841:        int __f;
        -: 2842:        for (__f = __fd; __d > __db && __f > 0; --__f)
        -: 2843:          *__me++ = *--__d;
        -: 2844:        char_type __z = __f > 0 ? __ct.widen('0') : char_type();
        -: 2845:        for (; __f > 0; --__f)
        -: 2846:          *__me++ = __z;
        -: 2847:        *__me++ = __dp;
        -: 2848:      }
        -: 2849:      // print units part
        -: 2850:      if (__d == __db) {
        -: 2851:        *__me++ = __ct.widen('0');
        -: 2852:      } else {
        -: 2853:        unsigned __ng = 0;
        -: 2854:        unsigned __ig = 0;
        -: 2855:        unsigned __gl = __grp.empty() ? numeric_limits<unsigned>::max() : static_cast<unsigned>(__grp[__ig]);
        -: 2856:        while (__d != __db) {
        -: 2857:          if (__ng == __gl) {
        -: 2858:            *__me++ = __ts;
        -: 2859:            __ng    = 0;
        -: 2860:            if (++__ig < __grp.size())
        -: 2861:              __gl = __grp[__ig] == numeric_limits<char>::max()
        -: 2862:                       ? numeric_limits<unsigned>::max()
        -: 2863:                       : static_cast<unsigned>(__grp[__ig]);
        -: 2864:          }
        -: 2865:          *__me++ = *--__d;
        -: 2866:          ++__ng;
        -: 2867:        }
        -: 2868:      }
        -: 2869:      // reverse it
        -: 2870:      std::reverse(__t, __me);
        -: 2871:    } break;
        -: 2872:    }
        -: 2873:  }
        -: 2874:  // print rest of sign, if any
        -: 2875:  if (__sn.size() > 1)
        -: 2876:    __me = std::copy(__sn.begin() + 1, __sn.end(), __me);
        -: 2877:  // set alignment
        -: 2878:  if ((__flags & ios_base::adjustfield) == ios_base::left)
        -: 2879:    __mi = __me;
        -: 2880:  else if ((__flags & ios_base::adjustfield) != ios_base::internal)
        -: 2881:    __mi = __mb;
        -: 2882:}
        -: 2883:
        -: 2884:extern template class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS __money_put<char>;
        -: 2885:#  ifndef _LIBCPP_HAS_NO_WIDE_CHARACTERS
        -: 2886:extern template class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS __money_put<wchar_t>;
        -: 2887:#  endif
        -: 2888:
        -: 2889:template <class _CharT, class _OutputIterator = ostreambuf_iterator<_CharT> >
        -: 2890:class _LIBCPP_TEMPLATE_VIS money_put : public locale::facet, private __money_put<_CharT> {
        -: 2891:public:
        -: 2892:  typedef _CharT char_type;
        -: 2893:  typedef _OutputIterator iter_type;
        -: 2894:  typedef basic_string<char_type> string_type;
        -: 2895:
        -: 2896:  _LIBCPP_HIDE_FROM_ABI explicit money_put(size_t __refs = 0) : locale::facet(__refs) {}
        -: 2897:
        -: 2898:  _LIBCPP_HIDE_FROM_ABI iter_type
        -: 2899:  put(iter_type __s, bool __intl, ios_base& __iob, char_type __fl, long double __units) const {
        -: 2900:    return do_put(__s, __intl, __iob, __fl, __units);
        -: 2901:  }
        -: 2902:
        -: 2903:  _LIBCPP_HIDE_FROM_ABI iter_type
        -: 2904:  put(iter_type __s, bool __intl, ios_base& __iob, char_type __fl, const string_type& __digits) const {
        -: 2905:    return do_put(__s, __intl, __iob, __fl, __digits);
        -: 2906:  }
        -: 2907:
        -: 2908:  static locale::id id;
        -: 2909:
        -: 2910:protected:
        -: 2911:  _LIBCPP_HIDE_FROM_ABI_VIRTUAL ~money_put() override {}
        -: 2912:
        -: 2913:  virtual iter_type do_put(iter_type __s, bool __intl, ios_base& __iob, char_type __fl, long double __units) const;
        -: 2914:  virtual iter_type
        -: 2915:  do_put(iter_type __s, bool __intl, ios_base& __iob, char_type __fl, const string_type& __digits) const;
        -: 2916:};
        -: 2917:
        -: 2918:template <class _CharT, class _OutputIterator>
        -: 2919:locale::id money_put<_CharT, _OutputIterator>::id;
        -: 2920:
        -: 2921:template <class _CharT, class _OutputIterator>
        -: 2922:_OutputIterator money_put<_CharT, _OutputIterator>::do_put(
        -: 2923:    iter_type __s, bool __intl, ios_base& __iob, char_type __fl, long double __units) const {
        -: 2924:  // convert to char
        -: 2925:  const size_t __bs = 100;
        -: 2926:  char __buf[__bs];
        -: 2927:  char* __bb = __buf;
        -: 2928:  char_type __digits[__bs];
        -: 2929:  char_type* __db = __digits;
        -: 2930:  int __n         = snprintf(__bb, __bs, "%.0Lf", __units);
        -: 2931:  unique_ptr<char, void (*)(void*)> __hn(nullptr, free);
        -: 2932:  unique_ptr<char_type, void (*)(void*)> __hd(0, free);
        -: 2933:  // secure memory for digit storage
        -: 2934:  if (static_cast<size_t>(__n) > __bs - 1) {
        -: 2935:    __n = __libcpp_asprintf_l(&__bb, _LIBCPP_GET_C_LOCALE, "%.0Lf", __units);
        -: 2936:    if (__n == -1)
        -: 2937:      __throw_bad_alloc();
        -: 2938:    __hn.reset(__bb);
        -: 2939:    __hd.reset((char_type*)malloc(static_cast<size_t>(__n) * sizeof(char_type)));
        -: 2940:    if (__hd == nullptr)
        -: 2941:      __throw_bad_alloc();
        -: 2942:    __db = __hd.get();
        -: 2943:  }
        -: 2944:  // gather info
        -: 2945:  locale __loc                 = __iob.getloc();
        -: 2946:  const ctype<char_type>& __ct = std::use_facet<ctype<char_type> >(__loc);
        -: 2947:  __ct.widen(__bb, __bb + __n, __db);
        -: 2948:  bool __neg = __n > 0 && __bb[0] == '-';
        -: 2949:  money_base::pattern __pat;
        -: 2950:  char_type __dp;
        -: 2951:  char_type __ts;
        -: 2952:  string __grp;
        -: 2953:  string_type __sym;
        -: 2954:  string_type __sn;
        -: 2955:  int __fd;
        -: 2956:  this->__gather_info(__intl, __neg, __loc, __pat, __dp, __ts, __grp, __sym, __sn, __fd);
        -: 2957:  // secure memory for formatting
        -: 2958:  char_type __mbuf[__bs];
        -: 2959:  char_type* __mb = __mbuf;
        -: 2960:  unique_ptr<char_type, void (*)(void*)> __hw(0, free);
        -: 2961:  size_t __exn = __n > __fd ? (static_cast<size_t>(__n) - static_cast<size_t>(__fd)) * 2 + __sn.size() + __sym.size() +
        -: 2962:                                  static_cast<size_t>(__fd) + 1
        -: 2963:                            : __sn.size() + __sym.size() + static_cast<size_t>(__fd) + 2;
        -: 2964:  if (__exn > __bs) {
        -: 2965:    __hw.reset((char_type*)malloc(__exn * sizeof(char_type)));
        -: 2966:    __mb = __hw.get();
        -: 2967:    if (__mb == 0)
        -: 2968:      __throw_bad_alloc();
        -: 2969:  }
        -: 2970:  // format
        -: 2971:  char_type* __mi;
        -: 2972:  char_type* __me;
        -: 2973:  this->__format(
        -: 2974:      __mb, __mi, __me, __iob.flags(), __db, __db + __n, __ct, __neg, __pat, __dp, __ts, __grp, __sym, __sn, __fd);
        -: 2975:  return std::__pad_and_output(__s, __mb, __mi, __me, __iob, __fl);
        -: 2976:}
        -: 2977:
        -: 2978:template <class _CharT, class _OutputIterator>
        -: 2979:_OutputIterator money_put<_CharT, _OutputIterator>::do_put(
        -: 2980:    iter_type __s, bool __intl, ios_base& __iob, char_type __fl, const string_type& __digits) const {
        -: 2981:  // gather info
        -: 2982:  locale __loc                 = __iob.getloc();
        -: 2983:  const ctype<char_type>& __ct = std::use_facet<ctype<char_type> >(__loc);
        -: 2984:  bool __neg                   = __digits.size() > 0 && __digits[0] == __ct.widen('-');
        -: 2985:  money_base::pattern __pat;
        -: 2986:  char_type __dp;
        -: 2987:  char_type __ts;
        -: 2988:  string __grp;
        -: 2989:  string_type __sym;
        -: 2990:  string_type __sn;
        -: 2991:  int __fd;
        -: 2992:  this->__gather_info(__intl, __neg, __loc, __pat, __dp, __ts, __grp, __sym, __sn, __fd);
        -: 2993:  // secure memory for formatting
        -: 2994:  char_type __mbuf[100];
        -: 2995:  char_type* __mb = __mbuf;
        -: 2996:  unique_ptr<char_type, void (*)(void*)> __h(0, free);
        -: 2997:  size_t __exn =
        -: 2998:      static_cast<int>(__digits.size()) > __fd
        -: 2999:          ? (__digits.size() - static_cast<size_t>(__fd)) * 2 + __sn.size() + __sym.size() + static_cast<size_t>(__fd) +
        -: 3000:                1
        -: 3001:          : __sn.size() + __sym.size() + static_cast<size_t>(__fd) + 2;
        -: 3002:  if (__exn > 100) {
        -: 3003:    __h.reset((char_type*)malloc(__exn * sizeof(char_type)));
        -: 3004:    __mb = __h.get();
        -: 3005:    if (__mb == 0)
        -: 3006:      __throw_bad_alloc();
        -: 3007:  }
        -: 3008:  // format
        -: 3009:  char_type* __mi;
        -: 3010:  char_type* __me;
        -: 3011:  this->__format(
        -: 3012:      __mb,
        -: 3013:      __mi,
        -: 3014:      __me,
        -: 3015:      __iob.flags(),
        -: 3016:      __digits.data(),
        -: 3017:      __digits.data() + __digits.size(),
        -: 3018:      __ct,
        -: 3019:      __neg,
        -: 3020:      __pat,
        -: 3021:      __dp,
        -: 3022:      __ts,
        -: 3023:      __grp,
        -: 3024:      __sym,
        -: 3025:      __sn,
        -: 3026:      __fd);
        -: 3027:  return std::__pad_and_output(__s, __mb, __mi, __me, __iob, __fl);
        -: 3028:}
        -: 3029:
        -: 3030:extern template class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS money_put<char>;
        -: 3031:#  ifndef _LIBCPP_HAS_NO_WIDE_CHARACTERS
        -: 3032:extern template class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS money_put<wchar_t>;
        -: 3033:#  endif
        -: 3034:
        -: 3035:// messages
        -: 3036:
        -: 3037:class _LIBCPP_EXPORTED_FROM_ABI messages_base {
        -: 3038:public:
        -: 3039:  typedef intptr_t catalog;
        -: 3040:
        -: 3041:  _LIBCPP_HIDE_FROM_ABI messages_base() {}
        -: 3042:};
        -: 3043:
        -: 3044:template <class _CharT>
        -: 3045:class _LIBCPP_TEMPLATE_VIS messages : public locale::facet, public messages_base {
        -: 3046:public:
        -: 3047:  typedef _CharT char_type;
        -: 3048:  typedef basic_string<_CharT> string_type;
        -: 3049:
        -: 3050:  _LIBCPP_HIDE_FROM_ABI explicit messages(size_t __refs = 0) : locale::facet(__refs) {}
        -: 3051:
        -: 3052:  _LIBCPP_HIDE_FROM_ABI catalog open(const basic_string<char>& __nm, const locale& __loc) const {
        -: 3053:    return do_open(__nm, __loc);
        -: 3054:  }
        -: 3055:
        -: 3056:  _LIBCPP_HIDE_FROM_ABI string_type get(catalog __c, int __set, int __msgid, const string_type& __dflt) const {
        -: 3057:    return do_get(__c, __set, __msgid, __dflt);
        -: 3058:  }
        -: 3059:
        -: 3060:  _LIBCPP_HIDE_FROM_ABI void close(catalog __c) const { do_close(__c); }
        -: 3061:
        -: 3062:  static locale::id id;
        -: 3063:
        -: 3064:protected:
        -: 3065:  _LIBCPP_HIDE_FROM_ABI_VIRTUAL ~messages() override {}
        -: 3066:
        -: 3067:  virtual catalog do_open(const basic_string<char>&, const locale&) const;
        -: 3068:  virtual string_type do_get(catalog, int __set, int __msgid, const string_type& __dflt) const;
        -: 3069:  virtual void do_close(catalog) const;
        -: 3070:};
        -: 3071:
        -: 3072:template <class _CharT>
        -: 3073:locale::id messages<_CharT>::id;
        -: 3074:
        -: 3075:template <class _CharT>
        -: 3076:typename messages<_CharT>::catalog messages<_CharT>::do_open(const basic_string<char>& __nm, const locale&) const {
        -: 3077:#  ifdef _LIBCPP_HAS_CATOPEN
        -: 3078:  return (catalog)catopen(__nm.c_str(), NL_CAT_LOCALE);
        -: 3079:#  else  // !_LIBCPP_HAS_CATOPEN
        -: 3080:  (void)__nm;
        -: 3081:  return -1;
        -: 3082:#  endif // _LIBCPP_HAS_CATOPEN
        -: 3083:}
        -: 3084:
        -: 3085:template <class _CharT>
        -: 3086:typename messages<_CharT>::string_type
        -: 3087:messages<_CharT>::do_get(catalog __c, int __set, int __msgid, const string_type& __dflt) const {
        -: 3088:#  ifdef _LIBCPP_HAS_CATOPEN
        -: 3089:  string __ndflt;
        -: 3090:  __narrow_to_utf8<sizeof(char_type) * __CHAR_BIT__>()(
        -: 3091:      std::back_inserter(__ndflt), __dflt.c_str(), __dflt.c_str() + __dflt.size());
        -: 3092:  nl_catd __cat = (nl_catd)__c;
        -: 3093:  static_assert(sizeof(catalog) >= sizeof(nl_catd), "Unexpected nl_catd type");
        -: 3094:  char* __n = catgets(__cat, __set, __msgid, __ndflt.c_str());
        -: 3095:  string_type __w;
        -: 3096:  __widen_from_utf8<sizeof(char_type) * __CHAR_BIT__>()(std::back_inserter(__w), __n, __n + std::strlen(__n));
        -: 3097:  return __w;
        -: 3098:#  else  // !_LIBCPP_HAS_CATOPEN
        -: 3099:  (void)__c;
        -: 3100:  (void)__set;
        -: 3101:  (void)__msgid;
        -: 3102:  return __dflt;
        -: 3103:#  endif // _LIBCPP_HAS_CATOPEN
        -: 3104:}
        -: 3105:
        -: 3106:template <class _CharT>
        -: 3107:void messages<_CharT>::do_close(catalog __c) const {
        -: 3108:#  ifdef _LIBCPP_HAS_CATOPEN
        -: 3109:  catclose((nl_catd)__c);
        -: 3110:#  else  // !_LIBCPP_HAS_CATOPEN
        -: 3111:  (void)__c;
        -: 3112:#  endif // _LIBCPP_HAS_CATOPEN
        -: 3113:}
        -: 3114:
        -: 3115:extern template class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS messages<char>;
        -: 3116:#  ifndef _LIBCPP_HAS_NO_WIDE_CHARACTERS
        -: 3117:extern template class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS messages<wchar_t>;
        -: 3118:#  endif
        -: 3119:
        -: 3120:template <class _CharT>
        -: 3121:class _LIBCPP_TEMPLATE_VIS messages_byname : public messages<_CharT> {
        -: 3122:public:
        -: 3123:  typedef messages_base::catalog catalog;
        -: 3124:  typedef basic_string<_CharT> string_type;
        -: 3125:
        -: 3126:  _LIBCPP_HIDE_FROM_ABI explicit messages_byname(const char*, size_t __refs = 0) : messages<_CharT>(__refs) {}
        -: 3127:
        -: 3128:  _LIBCPP_HIDE_FROM_ABI explicit messages_byname(const string&, size_t __refs = 0) : messages<_CharT>(__refs) {}
        -: 3129:
        -: 3130:protected:
        -: 3131:  _LIBCPP_HIDE_FROM_ABI_VIRTUAL ~messages_byname() override {}
        -: 3132:};
        -: 3133:
        -: 3134:extern template class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS messages_byname<char>;
        -: 3135:#  ifndef _LIBCPP_HAS_NO_WIDE_CHARACTERS
        -: 3136:extern template class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS messages_byname<wchar_t>;
        -: 3137:#  endif
        -: 3138:
        -: 3139:#  if _LIBCPP_STD_VER < 26 || defined(_LIBCPP_ENABLE_CXX26_REMOVED_WSTRING_CONVERT)
        -: 3140:
        -: 3141:template <class _Codecvt,
        -: 3142:          class _Elem      = wchar_t,
        -: 3143:          class _WideAlloc = allocator<_Elem>,
        -: 3144:          class _ByteAlloc = allocator<char> >
        -: 3145:class _LIBCPP_TEMPLATE_VIS _LIBCPP_DEPRECATED_IN_CXX17 wstring_convert {
        -: 3146:public:
        -: 3147:  typedef basic_string<char, char_traits<char>, _ByteAlloc> byte_string;
        -: 3148:  typedef basic_string<_Elem, char_traits<_Elem>, _WideAlloc> wide_string;
        -: 3149:  typedef typename _Codecvt::state_type state_type;
        -: 3150:  typedef typename wide_string::traits_type::int_type int_type;
        -: 3151:
        -: 3152:private:
        -: 3153:  byte_string __byte_err_string_;
        -: 3154:  wide_string __wide_err_string_;
        -: 3155:  _Codecvt* __cvtptr_;
        -: 3156:  state_type __cvtstate_;
        -: 3157:  size_t __cvtcount_;
        -: 3158:
        -: 3159:public:
        -: 3160:#    ifndef _LIBCPP_CXX03_LANG
        -: 3161:  _LIBCPP_HIDE_FROM_ABI wstring_convert() : wstring_convert(new _Codecvt) {}
        -: 3162:  _LIBCPP_HIDE_FROM_ABI explicit wstring_convert(_Codecvt* __pcvt);
        -: 3163:#    else
        -: 3164:  _LIBCPP_HIDE_FROM_ABI _LIBCPP_EXPLICIT_SINCE_CXX14 wstring_convert(_Codecvt* __pcvt = new _Codecvt);
        -: 3165:#    endif
        -: 3166:
        -: 3167:  _LIBCPP_HIDE_FROM_ABI wstring_convert(_Codecvt* __pcvt, state_type __state);
        -: 3168:  _LIBCPP_EXPLICIT_SINCE_CXX14 _LIBCPP_HIDE_FROM_ABI
        -: 3169:  wstring_convert(const byte_string& __byte_err, const wide_string& __wide_err = wide_string());
        -: 3170:#    ifndef _LIBCPP_CXX03_LANG
        -: 3171:  _LIBCPP_HIDE_FROM_ABI wstring_convert(wstring_convert&& __wc);
        -: 3172:#    endif
        -: 3173:  _LIBCPP_HIDE_FROM_ABI ~wstring_convert();
        -: 3174:
        -: 3175:  wstring_convert(const wstring_convert& __wc)            = delete;
        -: 3176:  wstring_convert& operator=(const wstring_convert& __wc) = delete;
        -: 3177:
        -: 3178:  _LIBCPP_HIDE_FROM_ABI wide_string from_bytes(char __byte) { return from_bytes(&__byte, &__byte + 1); }
        -: 3179:  _LIBCPP_HIDE_FROM_ABI wide_string from_bytes(const char* __ptr) {
        -: 3180:    return from_bytes(__ptr, __ptr + char_traits<char>::length(__ptr));
        -: 3181:  }
        -: 3182:  _LIBCPP_HIDE_FROM_ABI wide_string from_bytes(const byte_string& __str) {
        -: 3183:    return from_bytes(__str.data(), __str.data() + __str.size());
        -: 3184:  }
        -: 3185:  _LIBCPP_HIDE_FROM_ABI wide_string from_bytes(const char* __first, const char* __last);
        -: 3186:
        -: 3187:  _LIBCPP_HIDE_FROM_ABI byte_string to_bytes(_Elem __wchar) { return to_bytes(&__wchar, &__wchar + 1); }
        -: 3188:  _LIBCPP_HIDE_FROM_ABI byte_string to_bytes(const _Elem* __wptr) {
        -: 3189:    return to_bytes(__wptr, __wptr + char_traits<_Elem>::length(__wptr));
        -: 3190:  }
        -: 3191:  _LIBCPP_HIDE_FROM_ABI byte_string to_bytes(const wide_string& __wstr) {
        -: 3192:    return to_bytes(__wstr.data(), __wstr.data() + __wstr.size());
        -: 3193:  }
        -: 3194:  _LIBCPP_HIDE_FROM_ABI byte_string to_bytes(const _Elem* __first, const _Elem* __last);
        -: 3195:
        -: 3196:  _LIBCPP_HIDE_FROM_ABI size_t converted() const _NOEXCEPT { return __cvtcount_; }
        -: 3197:  _LIBCPP_HIDE_FROM_ABI state_type state() const { return __cvtstate_; }
        -: 3198:};
        -: 3199:
        -: 3200:_LIBCPP_SUPPRESS_DEPRECATED_PUSH
        -: 3201:template <class _Codecvt, class _Elem, class _WideAlloc, class _ByteAlloc>
        -: 3202:inline wstring_convert<_Codecvt, _Elem, _WideAlloc, _ByteAlloc>::wstring_convert(_Codecvt* __pcvt)
        -: 3203:    : __cvtptr_(__pcvt), __cvtstate_(), __cvtcount_(0) {}
        -: 3204:_LIBCPP_SUPPRESS_DEPRECATED_POP
        -: 3205:
        -: 3206:template <class _Codecvt, class _Elem, class _WideAlloc, class _ByteAlloc>
        -: 3207:inline wstring_convert<_Codecvt, _Elem, _WideAlloc, _ByteAlloc>::wstring_convert(_Codecvt* __pcvt, state_type __state)
        -: 3208:    : __cvtptr_(__pcvt), __cvtstate_(__state), __cvtcount_(0) {}
        -: 3209:
        -: 3210:template <class _Codecvt, class _Elem, class _WideAlloc, class _ByteAlloc>
        -: 3211:wstring_convert<_Codecvt, _Elem, _WideAlloc, _ByteAlloc>::wstring_convert(
        -: 3212:    const byte_string& __byte_err, const wide_string& __wide_err)
        -: 3213:    : __byte_err_string_(__byte_err), __wide_err_string_(__wide_err), __cvtstate_(), __cvtcount_(0) {
        -: 3214:  __cvtptr_ = new _Codecvt;
        -: 3215:}
        -: 3216:
        -: 3217:#    ifndef _LIBCPP_CXX03_LANG
        -: 3218:
        -: 3219:template <class _Codecvt, class _Elem, class _WideAlloc, class _ByteAlloc>
        -: 3220:inline wstring_convert<_Codecvt, _Elem, _WideAlloc, _ByteAlloc>::wstring_convert(wstring_convert&& __wc)
        -: 3221:    : __byte_err_string_(std::move(__wc.__byte_err_string_)),
        -: 3222:      __wide_err_string_(std::move(__wc.__wide_err_string_)),
        -: 3223:      __cvtptr_(__wc.__cvtptr_),
        -: 3224:      __cvtstate_(__wc.__cvtstate_),
        -: 3225:      __cvtcount_(__wc.__cvtcount_) {
        -: 3226:  __wc.__cvtptr_ = nullptr;
        -: 3227:}
        -: 3228:
        -: 3229:#    endif // _LIBCPP_CXX03_LANG
        -: 3230:
        -: 3231:_LIBCPP_SUPPRESS_DEPRECATED_PUSH
        -: 3232:template <class _Codecvt, class _Elem, class _WideAlloc, class _ByteAlloc>
        -: 3233:wstring_convert<_Codecvt, _Elem, _WideAlloc, _ByteAlloc>::~wstring_convert() {
        -: 3234:  delete __cvtptr_;
        -: 3235:}
        -: 3236:
        -: 3237:template <class _Codecvt, class _Elem, class _WideAlloc, class _ByteAlloc>
        -: 3238:typename wstring_convert<_Codecvt, _Elem, _WideAlloc, _ByteAlloc>::wide_string
        -: 3239:wstring_convert<_Codecvt, _Elem, _WideAlloc, _ByteAlloc>::from_bytes(const char* __frm, const char* __frm_end) {
        -: 3240:  _LIBCPP_SUPPRESS_DEPRECATED_POP
        -: 3241:  __cvtcount_ = 0;
        -: 3242:  if (__cvtptr_ != nullptr) {
        -: 3243:    wide_string __ws(2 * (__frm_end - __frm), _Elem());
        -: 3244:    if (__frm != __frm_end)
        -: 3245:      __ws.resize(__ws.capacity());
        -: 3246:    codecvt_base::result __r = codecvt_base::ok;
        -: 3247:    state_type __st          = __cvtstate_;
        -: 3248:    if (__frm != __frm_end) {
        -: 3249:      _Elem* __to     = &__ws[0];
        -: 3250:      _Elem* __to_end = __to + __ws.size();
        -: 3251:      const char* __frm_nxt;
        -: 3252:      do {
        -: 3253:        _Elem* __to_nxt;
        -: 3254:        __r = __cvtptr_->in(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
        -: 3255:        __cvtcount_ += __frm_nxt - __frm;
        -: 3256:        if (__frm_nxt == __frm) {
        -: 3257:          __r = codecvt_base::error;
        -: 3258:        } else if (__r == codecvt_base::noconv) {
        -: 3259:          __ws.resize(__to - &__ws[0]);
        -: 3260:          // This only gets executed if _Elem is char
        -: 3261:          __ws.append((const _Elem*)__frm, (const _Elem*)__frm_end);
        -: 3262:          __frm = __frm_nxt;
        -: 3263:          __r   = codecvt_base::ok;
        -: 3264:        } else if (__r == codecvt_base::ok) {
        -: 3265:          __ws.resize(__to_nxt - &__ws[0]);
        -: 3266:          __frm = __frm_nxt;
        -: 3267:        } else if (__r == codecvt_base::partial) {
        -: 3268:          ptrdiff_t __s = __to_nxt - &__ws[0];
        -: 3269:          __ws.resize(2 * __s);
        -: 3270:          __to     = &__ws[0] + __s;
        -: 3271:          __to_end = &__ws[0] + __ws.size();
        -: 3272:          __frm    = __frm_nxt;
        -: 3273:        }
        -: 3274:      } while (__r == codecvt_base::partial && __frm_nxt < __frm_end);
        -: 3275:    }
        -: 3276:    if (__r == codecvt_base::ok)
        -: 3277:      return __ws;
        -: 3278:  }
        -: 3279:
        -: 3280:  if (__wide_err_string_.empty())
        -: 3281:    __throw_range_error("wstring_convert: from_bytes error");
        -: 3282:
        -: 3283:  return __wide_err_string_;
        -: 3284:}
        -: 3285:
        -: 3286:template <class _Codecvt, class _Elem, class _WideAlloc, class _ByteAlloc>
        -: 3287:typename wstring_convert<_Codecvt, _Elem, _WideAlloc, _ByteAlloc>::byte_string
        -: 3288:wstring_convert<_Codecvt, _Elem, _WideAlloc, _ByteAlloc>::to_bytes(const _Elem* __frm, const _Elem* __frm_end) {
        -: 3289:  __cvtcount_ = 0;
        -: 3290:  if (__cvtptr_ != nullptr) {
        -: 3291:    byte_string __bs(2 * (__frm_end - __frm), char());
        -: 3292:    if (__frm != __frm_end)
        -: 3293:      __bs.resize(__bs.capacity());
        -: 3294:    codecvt_base::result __r = codecvt_base::ok;
        -: 3295:    state_type __st          = __cvtstate_;
        -: 3296:    if (__frm != __frm_end) {
        -: 3297:      char* __to     = &__bs[0];
        -: 3298:      char* __to_end = __to + __bs.size();
        -: 3299:      const _Elem* __frm_nxt;
        -: 3300:      do {
        -: 3301:        char* __to_nxt;
        -: 3302:        __r = __cvtptr_->out(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
        -: 3303:        __cvtcount_ += __frm_nxt - __frm;
        -: 3304:        if (__frm_nxt == __frm) {
        -: 3305:          __r = codecvt_base::error;
        -: 3306:        } else if (__r == codecvt_base::noconv) {
        -: 3307:          __bs.resize(__to - &__bs[0]);
        -: 3308:          // This only gets executed if _Elem is char
        -: 3309:          __bs.append((const char*)__frm, (const char*)__frm_end);
        -: 3310:          __frm = __frm_nxt;
        -: 3311:          __r   = codecvt_base::ok;
        -: 3312:        } else if (__r == codecvt_base::ok) {
        -: 3313:          __bs.resize(__to_nxt - &__bs[0]);
        -: 3314:          __frm = __frm_nxt;
        -: 3315:        } else if (__r == codecvt_base::partial) {
        -: 3316:          ptrdiff_t __s = __to_nxt - &__bs[0];
        -: 3317:          __bs.resize(2 * __s);
        -: 3318:          __to     = &__bs[0] + __s;
        -: 3319:          __to_end = &__bs[0] + __bs.size();
        -: 3320:          __frm    = __frm_nxt;
        -: 3321:        }
        -: 3322:      } while (__r == codecvt_base::partial && __frm_nxt < __frm_end);
        -: 3323:    }
        -: 3324:    if (__r == codecvt_base::ok) {
        -: 3325:      size_t __s = __bs.size();
        -: 3326:      __bs.resize(__bs.capacity());
        -: 3327:      char* __to     = &__bs[0] + __s;
        -: 3328:      char* __to_end = __to + __bs.size();
        -: 3329:      do {
        -: 3330:        char* __to_nxt;
        -: 3331:        __r = __cvtptr_->unshift(__st, __to, __to_end, __to_nxt);
        -: 3332:        if (__r == codecvt_base::noconv) {
        -: 3333:          __bs.resize(__to - &__bs[0]);
        -: 3334:          __r = codecvt_base::ok;
        -: 3335:        } else if (__r == codecvt_base::ok) {
        -: 3336:          __bs.resize(__to_nxt - &__bs[0]);
        -: 3337:        } else if (__r == codecvt_base::partial) {
        -: 3338:          ptrdiff_t __sp = __to_nxt - &__bs[0];
        -: 3339:          __bs.resize(2 * __sp);
        -: 3340:          __to     = &__bs[0] + __sp;
        -: 3341:          __to_end = &__bs[0] + __bs.size();
        -: 3342:        }
        -: 3343:      } while (__r == codecvt_base::partial);
        -: 3344:      if (__r == codecvt_base::ok)
        -: 3345:        return __bs;
        -: 3346:    }
        -: 3347:  }
        -: 3348:
        -: 3349:  if (__byte_err_string_.empty())
        -: 3350:    __throw_range_error("wstring_convert: to_bytes error");
        -: 3351:
        -: 3352:  return __byte_err_string_;
        -: 3353:}
        -: 3354:
        -: 3355:template <class _Codecvt, class _Elem = wchar_t, class _Tr = char_traits<_Elem> >
        -: 3356:class _LIBCPP_TEMPLATE_VIS _LIBCPP_DEPRECATED_IN_CXX17 wbuffer_convert : public basic_streambuf<_Elem, _Tr> {
        -: 3357:public:
        -: 3358:  // types:
        -: 3359:  typedef _Elem char_type;
        -: 3360:  typedef _Tr traits_type;
        -: 3361:  typedef typename traits_type::int_type int_type;
        -: 3362:  typedef typename traits_type::pos_type pos_type;
        -: 3363:  typedef typename traits_type::off_type off_type;
        -: 3364:  typedef typename _Codecvt::state_type state_type;
        -: 3365:
        -: 3366:private:
        -: 3367:  char* __extbuf_;
        -: 3368:  const char* __extbufnext_;
        -: 3369:  const char* __extbufend_;
        -: 3370:  char __extbuf_min_[8];
        -: 3371:  size_t __ebs_;
        -: 3372:  char_type* __intbuf_;
        -: 3373:  size_t __ibs_;
        -: 3374:  streambuf* __bufptr_;
        -: 3375:  _Codecvt* __cv_;
        -: 3376:  state_type __st_;
        -: 3377:  ios_base::openmode __cm_;
        -: 3378:  bool __owns_eb_;
        -: 3379:  bool __owns_ib_;
        -: 3380:  bool __always_noconv_;
        -: 3381:
        -: 3382:public:
        -: 3383:#    ifndef _LIBCPP_CXX03_LANG
        -: 3384:  _LIBCPP_HIDE_FROM_ABI wbuffer_convert() : wbuffer_convert(nullptr) {}
        -: 3385:  explicit _LIBCPP_HIDE_FROM_ABI
        -: 3386:  wbuffer_convert(streambuf* __bytebuf, _Codecvt* __pcvt = new _Codecvt, state_type __state = state_type());
        -: 3387:#    else
        -: 3388:  _LIBCPP_EXPLICIT_SINCE_CXX14 _LIBCPP_HIDE_FROM_ABI
        -: 3389:  wbuffer_convert(streambuf* __bytebuf = nullptr, _Codecvt* __pcvt = new _Codecvt, state_type __state = state_type());
        -: 3390:#    endif
        -: 3391:
        -: 3392:  _LIBCPP_HIDE_FROM_ABI ~wbuffer_convert();
        -: 3393:
        -: 3394:  _LIBCPP_HIDE_FROM_ABI streambuf* rdbuf() const { return __bufptr_; }
        -: 3395:  _LIBCPP_HIDE_FROM_ABI streambuf* rdbuf(streambuf* __bytebuf) {
        -: 3396:    streambuf* __r = __bufptr_;
        -: 3397:    __bufptr_      = __bytebuf;
        -: 3398:    return __r;
        -: 3399:  }
        -: 3400:
        -: 3401:  wbuffer_convert(const wbuffer_convert&)            = delete;
        -: 3402:  wbuffer_convert& operator=(const wbuffer_convert&) = delete;
        -: 3403:
        -: 3404:  _LIBCPP_HIDE_FROM_ABI state_type state() const { return __st_; }
        -: 3405:
        -: 3406:protected:
        -: 3407:  _LIBCPP_HIDE_FROM_ABI_VIRTUAL virtual int_type underflow();
        -: 3408:  _LIBCPP_HIDE_FROM_ABI_VIRTUAL virtual int_type pbackfail(int_type __c = traits_type::eof());
        -: 3409:  _LIBCPP_HIDE_FROM_ABI_VIRTUAL virtual int_type overflow(int_type __c = traits_type::eof());
        -: 3410:  _LIBCPP_HIDE_FROM_ABI_VIRTUAL virtual basic_streambuf<char_type, traits_type>* setbuf(char_type* __s, streamsize __n);
        -: 3411:  _LIBCPP_HIDE_FROM_ABI_VIRTUAL virtual pos_type
        -: 3412:  seekoff(off_type __off, ios_base::seekdir __way, ios_base::openmode __wch = ios_base::in | ios_base::out);
        -: 3413:  _LIBCPP_HIDE_FROM_ABI_VIRTUAL virtual pos_type
        -: 3414:  seekpos(pos_type __sp, ios_base::openmode __wch = ios_base::in | ios_base::out);
        -: 3415:  _LIBCPP_HIDE_FROM_ABI_VIRTUAL virtual int sync();
        -: 3416:
        -: 3417:private:
        -: 3418:  _LIBCPP_HIDE_FROM_ABI_VIRTUAL bool __read_mode();
        -: 3419:  _LIBCPP_HIDE_FROM_ABI_VIRTUAL void __write_mode();
        -: 3420:  _LIBCPP_HIDE_FROM_ABI_VIRTUAL wbuffer_convert* __close();
        -: 3421:};
        -: 3422:
        -: 3423:_LIBCPP_SUPPRESS_DEPRECATED_PUSH
        -: 3424:template <class _Codecvt, class _Elem, class _Tr>
        -: 3425:wbuffer_convert<_Codecvt, _Elem, _Tr>::wbuffer_convert(streambuf* __bytebuf, _Codecvt* __pcvt, state_type __state)
        -: 3426:    : __extbuf_(nullptr),
        -: 3427:      __extbufnext_(nullptr),
        -: 3428:      __extbufend_(nullptr),
        -: 3429:      __ebs_(0),
        -: 3430:      __intbuf_(0),
        -: 3431:      __ibs_(0),
        -: 3432:      __bufptr_(__bytebuf),
        -: 3433:      __cv_(__pcvt),
        -: 3434:      __st_(__state),
        -: 3435:      __cm_(0),
        -: 3436:      __owns_eb_(false),
        -: 3437:      __owns_ib_(false),
        -: 3438:      __always_noconv_(__cv_ ? __cv_->always_noconv() : false) {
        -: 3439:  setbuf(0, 4096);
        -: 3440:}
        -: 3441:
        -: 3442:template <class _Codecvt, class _Elem, class _Tr>
        -: 3443:wbuffer_convert<_Codecvt, _Elem, _Tr>::~wbuffer_convert() {
        -: 3444:  __close();
        -: 3445:  delete __cv_;
        -: 3446:  if (__owns_eb_)
        -: 3447:    delete[] __extbuf_;
        -: 3448:  if (__owns_ib_)
        -: 3449:    delete[] __intbuf_;
        -: 3450:}
        -: 3451:
        -: 3452:template <class _Codecvt, class _Elem, class _Tr>
        -: 3453:typename wbuffer_convert<_Codecvt, _Elem, _Tr>::int_type wbuffer_convert<_Codecvt, _Elem, _Tr>::underflow() {
        -: 3454:  _LIBCPP_SUPPRESS_DEPRECATED_POP
        -: 3455:  if (__cv_ == 0 || __bufptr_ == nullptr)
        -: 3456:    return traits_type::eof();
        -: 3457:  bool __initial = __read_mode();
        -: 3458:  char_type __1buf;
        -: 3459:  if (this->gptr() == 0)
        -: 3460:    this->setg(&__1buf, &__1buf + 1, &__1buf + 1);
        -: 3461:  const size_t __unget_sz = __initial ? 0 : std::min<size_t>((this->egptr() - this->eback()) / 2, 4);
        -: 3462:  int_type __c            = traits_type::eof();
        -: 3463:  if (this->gptr() == this->egptr()) {
        -: 3464:    std::memmove(this->eback(), this->egptr() - __unget_sz, __unget_sz * sizeof(char_type));
        -: 3465:    if (__always_noconv_) {
        -: 3466:      streamsize __nmemb = static_cast<streamsize>(this->egptr() - this->eback() - __unget_sz);
        -: 3467:      __nmemb            = __bufptr_->sgetn((char*)this->eback() + __unget_sz, __nmemb);
        -: 3468:      if (__nmemb != 0) {
        -: 3469:        this->setg(this->eback(), this->eback() + __unget_sz, this->eback() + __unget_sz + __nmemb);
        -: 3470:        __c = *this->gptr();
        -: 3471:      }
        -: 3472:    } else {
        -: 3473:      if (__extbufend_ != __extbufnext_) {
        -: 3474:        _LIBCPP_ASSERT_NON_NULL(__extbufnext_ != nullptr, "underflow moving from nullptr");
        -: 3475:        _LIBCPP_ASSERT_NON_NULL(__extbuf_ != nullptr, "underflow moving into nullptr");
        -: 3476:        std::memmove(__extbuf_, __extbufnext_, __extbufend_ - __extbufnext_);
        -: 3477:      }
        -: 3478:      __extbufnext_      = __extbuf_ + (__extbufend_ - __extbufnext_);
        -: 3479:      __extbufend_       = __extbuf_ + (__extbuf_ == __extbuf_min_ ? sizeof(__extbuf_min_) : __ebs_);
        -: 3480:      streamsize __nmemb = std::min(static_cast<streamsize>(this->egptr() - this->eback() - __unget_sz),
        -: 3481:                                    static_cast<streamsize>(__extbufend_ - __extbufnext_));
        -: 3482:      codecvt_base::result __r;
        -: 3483:      // FIXME: Do we ever need to restore the state here?
        -: 3484:      // state_type __svs = __st_;
        -: 3485:      streamsize __nr = __bufptr_->sgetn(const_cast<char*>(__extbufnext_), __nmemb);
        -: 3486:      if (__nr != 0) {
        -: 3487:        __extbufend_ = __extbufnext_ + __nr;
        -: 3488:        char_type* __inext;
        -: 3489:        __r = __cv_->in(
        -: 3490:            __st_, __extbuf_, __extbufend_, __extbufnext_, this->eback() + __unget_sz, this->egptr(), __inext);
        -: 3491:        if (__r == codecvt_base::noconv) {
        -: 3492:          this->setg((char_type*)__extbuf_, (char_type*)__extbuf_, (char_type*)const_cast<char*>(__extbufend_));
        -: 3493:          __c = *this->gptr();
        -: 3494:        } else if (__inext != this->eback() + __unget_sz) {
        -: 3495:          this->setg(this->eback(), this->eback() + __unget_sz, __inext);
        -: 3496:          __c = *this->gptr();
        -: 3497:        }
        -: 3498:      }
        -: 3499:    }
        -: 3500:  } else
        -: 3501:    __c = *this->gptr();
        -: 3502:  if (this->eback() == &__1buf)
        -: 3503:    this->setg(0, 0, 0);
        -: 3504:  return __c;
        -: 3505:}
        -: 3506:
        -: 3507:_LIBCPP_SUPPRESS_DEPRECATED_PUSH
        -: 3508:template <class _Codecvt, class _Elem, class _Tr>
        -: 3509:typename wbuffer_convert<_Codecvt, _Elem, _Tr>::int_type
        -: 3510:wbuffer_convert<_Codecvt, _Elem, _Tr>::pbackfail(int_type __c) {
        -: 3511:  _LIBCPP_SUPPRESS_DEPRECATED_POP
        -: 3512:  if (__cv_ != 0 && __bufptr_ && this->eback() < this->gptr()) {
        -: 3513:    if (traits_type::eq_int_type(__c, traits_type::eof())) {
        -: 3514:      this->gbump(-1);
        -: 3515:      return traits_type::not_eof(__c);
        -: 3516:    }
        -: 3517:    if (traits_type::eq(traits_type::to_char_type(__c), this->gptr()[-1])) {
        -: 3518:      this->gbump(-1);
        -: 3519:      *this->gptr() = traits_type::to_char_type(__c);
        -: 3520:      return __c;
        -: 3521:    }
        -: 3522:  }
        -: 3523:  return traits_type::eof();
        -: 3524:}
        -: 3525:
        -: 3526:_LIBCPP_SUPPRESS_DEPRECATED_PUSH
        -: 3527:template <class _Codecvt, class _Elem, class _Tr>
        -: 3528:typename wbuffer_convert<_Codecvt, _Elem, _Tr>::int_type wbuffer_convert<_Codecvt, _Elem, _Tr>::overflow(int_type __c) {
        -: 3529:  _LIBCPP_SUPPRESS_DEPRECATED_POP
        -: 3530:  if (__cv_ == 0 || !__bufptr_)
        -: 3531:    return traits_type::eof();
        -: 3532:  __write_mode();
        -: 3533:  char_type __1buf;
        -: 3534:  char_type* __pb_save  = this->pbase();
        -: 3535:  char_type* __epb_save = this->epptr();
        -: 3536:  if (!traits_type::eq_int_type(__c, traits_type::eof())) {
        -: 3537:    if (this->pptr() == 0)
        -: 3538:      this->setp(&__1buf, &__1buf + 1);
        -: 3539:    *this->pptr() = traits_type::to_char_type(__c);
        -: 3540:    this->pbump(1);
        -: 3541:  }
        -: 3542:  if (this->pptr() != this->pbase()) {
        -: 3543:    if (__always_noconv_) {
        -: 3544:      streamsize __nmemb = static_cast<streamsize>(this->pptr() - this->pbase());
        -: 3545:      if (__bufptr_->sputn((const char*)this->pbase(), __nmemb) != __nmemb)
        -: 3546:        return traits_type::eof();
        -: 3547:    } else {
        -: 3548:      char* __extbe = __extbuf_;
        -: 3549:      codecvt_base::result __r;
        -: 3550:      do {
        -: 3551:        const char_type* __e;
        -: 3552:        __r = __cv_->out(__st_, this->pbase(), this->pptr(), __e, __extbuf_, __extbuf_ + __ebs_, __extbe);
        -: 3553:        if (__e == this->pbase())
        -: 3554:          return traits_type::eof();
        -: 3555:        if (__r == codecvt_base::noconv) {
        -: 3556:          streamsize __nmemb = static_cast<size_t>(this->pptr() - this->pbase());
        -: 3557:          if (__bufptr_->sputn((const char*)this->pbase(), __nmemb) != __nmemb)
        -: 3558:            return traits_type::eof();
        -: 3559:        } else if (__r == codecvt_base::ok || __r == codecvt_base::partial) {
        -: 3560:          streamsize __nmemb = static_cast<size_t>(__extbe - __extbuf_);
        -: 3561:          if (__bufptr_->sputn(__extbuf_, __nmemb) != __nmemb)
        -: 3562:            return traits_type::eof();
        -: 3563:          if (__r == codecvt_base::partial) {
        -: 3564:            this->setp(const_cast<char_type*>(__e), this->pptr());
        -: 3565:            this->__pbump(this->epptr() - this->pbase());
        -: 3566:          }
        -: 3567:        } else
        -: 3568:          return traits_type::eof();
        -: 3569:      } while (__r == codecvt_base::partial);
        -: 3570:    }
        -: 3571:    this->setp(__pb_save, __epb_save);
        -: 3572:  }
        -: 3573:  return traits_type::not_eof(__c);
        -: 3574:}
        -: 3575:
        -: 3576:_LIBCPP_SUPPRESS_DEPRECATED_PUSH
        -: 3577:template <class _Codecvt, class _Elem, class _Tr>
        -: 3578:basic_streambuf<_Elem, _Tr>* wbuffer_convert<_Codecvt, _Elem, _Tr>::setbuf(char_type* __s, streamsize __n) {
        -: 3579:  _LIBCPP_SUPPRESS_DEPRECATED_POP
        -: 3580:  this->setg(0, 0, 0);
        -: 3581:  this->setp(0, 0);
        -: 3582:  if (__owns_eb_)
        -: 3583:    delete[] __extbuf_;
        -: 3584:  if (__owns_ib_)
        -: 3585:    delete[] __intbuf_;
        -: 3586:  __ebs_ = __n;
        -: 3587:  if (__ebs_ > sizeof(__extbuf_min_)) {
        -: 3588:    if (__always_noconv_ && __s) {
        -: 3589:      __extbuf_  = (char*)__s;
        -: 3590:      __owns_eb_ = false;
        -: 3591:    } else {
        -: 3592:      __extbuf_  = new char[__ebs_];
        -: 3593:      __owns_eb_ = true;
        -: 3594:    }
        -: 3595:  } else {
        -: 3596:    __extbuf_  = __extbuf_min_;
        -: 3597:    __ebs_     = sizeof(__extbuf_min_);
        -: 3598:    __owns_eb_ = false;
        -: 3599:  }
        -: 3600:  if (!__always_noconv_) {
        -: 3601:    __ibs_ = max<streamsize>(__n, sizeof(__extbuf_min_));
        -: 3602:    if (__s && __ibs_ >= sizeof(__extbuf_min_)) {
        -: 3603:      __intbuf_  = __s;
        -: 3604:      __owns_ib_ = false;
        -: 3605:    } else {
        -: 3606:      __intbuf_  = new char_type[__ibs_];
        -: 3607:      __owns_ib_ = true;
        -: 3608:    }
        -: 3609:  } else {
        -: 3610:    __ibs_     = 0;
        -: 3611:    __intbuf_  = 0;
        -: 3612:    __owns_ib_ = false;
        -: 3613:  }
        -: 3614:  return this;
        -: 3615:}
        -: 3616:
        -: 3617:_LIBCPP_SUPPRESS_DEPRECATED_PUSH
        -: 3618:template <class _Codecvt, class _Elem, class _Tr>
        -: 3619:typename wbuffer_convert<_Codecvt, _Elem, _Tr>::pos_type
        -: 3620:wbuffer_convert<_Codecvt, _Elem, _Tr>::seekoff(off_type __off, ios_base::seekdir __way, ios_base::openmode __om) {
        -: 3621:  int __width = __cv_->encoding();
        -: 3622:  if (__cv_ == 0 || !__bufptr_ || (__width <= 0 && __off != 0) || sync())
        -: 3623:    return pos_type(off_type(-1));
        -: 3624:  // __width > 0 || __off == 0, now check __way
        -: 3625:  if (__way != ios_base::beg && __way != ios_base::cur && __way != ios_base::end)
        -: 3626:    return pos_type(off_type(-1));
        -: 3627:  pos_type __r = __bufptr_->pubseekoff(__width * __off, __way, __om);
        -: 3628:  __r.state(__st_);
        -: 3629:  return __r;
        -: 3630:}
        -: 3631:
        -: 3632:template <class _Codecvt, class _Elem, class _Tr>
        -: 3633:typename wbuffer_convert<_Codecvt, _Elem, _Tr>::pos_type
        -: 3634:wbuffer_convert<_Codecvt, _Elem, _Tr>::seekpos(pos_type __sp, ios_base::openmode __wch) {
        -: 3635:  if (__cv_ == 0 || !__bufptr_ || sync())
        -: 3636:    return pos_type(off_type(-1));
        -: 3637:  if (__bufptr_->pubseekpos(__sp, __wch) == pos_type(off_type(-1)))
        -: 3638:    return pos_type(off_type(-1));
        -: 3639:  return __sp;
        -: 3640:}
        -: 3641:
        -: 3642:template <class _Codecvt, class _Elem, class _Tr>
        -: 3643:int wbuffer_convert<_Codecvt, _Elem, _Tr>::sync() {
        -: 3644:  _LIBCPP_SUPPRESS_DEPRECATED_POP
        -: 3645:  if (__cv_ == 0 || !__bufptr_)
        -: 3646:    return 0;
        -: 3647:  if (__cm_ & ios_base::out) {
        -: 3648:    if (this->pptr() != this->pbase())
        -: 3649:      if (overflow() == traits_type::eof())
        -: 3650:        return -1;
        -: 3651:    codecvt_base::result __r;
        -: 3652:    do {
        -: 3653:      char* __extbe;
        -: 3654:      __r                = __cv_->unshift(__st_, __extbuf_, __extbuf_ + __ebs_, __extbe);
        -: 3655:      streamsize __nmemb = static_cast<streamsize>(__extbe - __extbuf_);
        -: 3656:      if (__bufptr_->sputn(__extbuf_, __nmemb) != __nmemb)
        -: 3657:        return -1;
        -: 3658:    } while (__r == codecvt_base::partial);
        -: 3659:    if (__r == codecvt_base::error)
        -: 3660:      return -1;
        -: 3661:    if (__bufptr_->pubsync())
        -: 3662:      return -1;
        -: 3663:  } else if (__cm_ & ios_base::in) {
        -: 3664:    off_type __c;
        -: 3665:    if (__always_noconv_)
        -: 3666:      __c = this->egptr() - this->gptr();
        -: 3667:    else {
        -: 3668:      int __width = __cv_->encoding();
        -: 3669:      __c         = __extbufend_ - __extbufnext_;
        -: 3670:      if (__width > 0)
        -: 3671:        __c += __width * (this->egptr() - this->gptr());
        -: 3672:      else {
        -: 3673:        if (this->gptr() != this->egptr()) {
        -: 3674:          std::reverse(this->gptr(), this->egptr());
        -: 3675:          codecvt_base::result __r;
        -: 3676:          const char_type* __e = this->gptr();
        -: 3677:          char* __extbe;
        -: 3678:          do {
        -: 3679:            __r = __cv_->out(__st_, __e, this->egptr(), __e, __extbuf_, __extbuf_ + __ebs_, __extbe);
        -: 3680:            switch (__r) {
        -: 3681:            case codecvt_base::noconv:
        -: 3682:              __c += this->egptr() - this->gptr();
        -: 3683:              break;
        -: 3684:            case codecvt_base::ok:
        -: 3685:            case codecvt_base::partial:
        -: 3686:              __c += __extbe - __extbuf_;
        -: 3687:              break;
        -: 3688:            default:
        -: 3689:              return -1;
        -: 3690:            }
        -: 3691:          } while (__r == codecvt_base::partial);
        -: 3692:        }
        -: 3693:      }
        -: 3694:    }
        -: 3695:    if (__bufptr_->pubseekoff(-__c, ios_base::cur, __cm_) == pos_type(off_type(-1)))
        -: 3696:      return -1;
        -: 3697:    this->setg(0, 0, 0);
        -: 3698:    __cm_ = 0;
        -: 3699:  }
        -: 3700:  return 0;
        -: 3701:}
        -: 3702:
        -: 3703:_LIBCPP_SUPPRESS_DEPRECATED_PUSH
        -: 3704:template <class _Codecvt, class _Elem, class _Tr>
        -: 3705:bool wbuffer_convert<_Codecvt, _Elem, _Tr>::__read_mode() {
        -: 3706:  if (!(__cm_ & ios_base::in)) {
        -: 3707:    this->setp(0, 0);
        -: 3708:    if (__always_noconv_)
        -: 3709:      this->setg((char_type*)__extbuf_, (char_type*)__extbuf_ + __ebs_, (char_type*)__extbuf_ + __ebs_);
        -: 3710:    else
        -: 3711:      this->setg(__intbuf_, __intbuf_ + __ibs_, __intbuf_ + __ibs_);
        -: 3712:    __cm_ = ios_base::in;
        -: 3713:    return true;
        -: 3714:  }
        -: 3715:  return false;
        -: 3716:}
        -: 3717:
        -: 3718:template <class _Codecvt, class _Elem, class _Tr>
        -: 3719:void wbuffer_convert<_Codecvt, _Elem, _Tr>::__write_mode() {
        -: 3720:  if (!(__cm_ & ios_base::out)) {
        -: 3721:    this->setg(0, 0, 0);
        -: 3722:    if (__ebs_ > sizeof(__extbuf_min_)) {
        -: 3723:      if (__always_noconv_)
        -: 3724:        this->setp((char_type*)__extbuf_, (char_type*)__extbuf_ + (__ebs_ - 1));
        -: 3725:      else
        -: 3726:        this->setp(__intbuf_, __intbuf_ + (__ibs_ - 1));
        -: 3727:    } else
        -: 3728:      this->setp(0, 0);
        -: 3729:    __cm_ = ios_base::out;
        -: 3730:  }
        -: 3731:}
        -: 3732:
        -: 3733:template <class _Codecvt, class _Elem, class _Tr>
        -: 3734:wbuffer_convert<_Codecvt, _Elem, _Tr>* wbuffer_convert<_Codecvt, _Elem, _Tr>::__close() {
        -: 3735:  wbuffer_convert* __rt = nullptr;
        -: 3736:  if (__cv_ != nullptr && __bufptr_ != nullptr) {
        -: 3737:    __rt = this;
        -: 3738:    if ((__cm_ & ios_base::out) && sync())
        -: 3739:      __rt = nullptr;
        -: 3740:  }
        -: 3741:  return __rt;
        -: 3742:}
        -: 3743:
        -: 3744:_LIBCPP_SUPPRESS_DEPRECATED_POP
        -: 3745:
        -: 3746:#  endif // _LIBCPP_STD_VER < 26 || defined(_LIBCPP_ENABLE_CXX26_REMOVED_WSTRING_CONVERT)
        -: 3747:
        -: 3748:_LIBCPP_END_NAMESPACE_STD
        -: 3749:
        -: 3750:_LIBCPP_POP_MACROS
        -: 3751:
        -: 3752:// NOLINTEND(libcpp-robust-against-adl)
        -: 3753:
        -: 3754:#endif // !defined(_LIBCPP_HAS_NO_LOCALIZATION)
        -: 3755:
        -: 3756:#if !defined(_LIBCPP_REMOVE_TRANSITIVE_INCLUDES) && _LIBCPP_STD_VER <= 20
        -: 3757:#  include <atomic>
        -: 3758:#  include <concepts>
        -: 3759:#  include <cstdarg>
        -: 3760:#  include <iterator>
        -: 3761:#  include <mutex>
        -: 3762:#  include <stdexcept>
        -: 3763:#  include <type_traits>
        -: 3764:#  include <typeinfo>
        -: 3765:#endif
        -: 3766:
        -: 3767:#endif // _LIBCPP_LOCALE
